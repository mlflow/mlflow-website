"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["3798"],{63454(e,n,r){r.r(n),r.d(n,{metadata:()=>o,default:()=>y,frontMatter:()=>h,contentTitle:()=>f,toc:()=>u,assets:()=>g});var o=JSON.parse('{"id":"traditional-ml/prophet/index","title":"MLflow Prophet Integration","description":"Introduction","source":"@site/docs/classic-ml/traditional-ml/prophet/index.mdx","sourceDirName":"traditional-ml/prophet","slug":"/traditional-ml/prophet/","permalink":"/mlflow-website/docs/latest/ml/traditional-ml/prophet/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"classicMLSidebar","previous":{"title":"SparkML","permalink":"/mlflow-website/docs/latest/ml/traditional-ml/sparkml/"},"next":{"title":"Overview","permalink":"/mlflow-website/docs/latest/ml/deep-learning/"}}'),t=r(74848),i=r(28453),a=r(33508),l=r(10440),s=r(77541),d=r(76316),c=r(61878),m=r(44471),p=r(17133);let h={},f="MLflow Prophet Integration",g={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Why MLflow + Prophet?",id:"why-mlflow--prophet",level:2},{value:"Basic Model Logging",id:"basic-model-logging",level:2},{value:"Cross-Validation Tracking",id:"cross-validation-tracking",level:2},{value:"Hyperparameter Optimization",id:"hyperparameter-optimization",level:2},{value:"Model Registry Integration",id:"model-registry-integration",level:2},{value:"Model Loading and Inference",id:"model-loading-and-inference",level:2},{value:"Batch Forecasting Workflow",id:"batch-forecasting-workflow",level:2},{value:"Forecast Component Logging",id:"forecast-component-logging",level:2},{value:"Learn More",id:"learn-more",level:2}];function _(e){let n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"mlflow-prophet-integration",children:"MLflow Prophet Integration"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Prophet"})," is Meta's open-source time series forecasting library designed for business forecasting tasks. It decomposes time series into trend, seasonality, and holiday effects, handling missing data and outliers while producing interpretable forecasts."]}),"\n",(0,t.jsx)(n.p,{children:"MLflow's Prophet integration provides experiment tracking, model versioning, and deployment capabilities for time series forecasting workflows."}),"\n",(0,t.jsx)(n.admonition,{title:"No Autologging for Prophet",type:"note",children:(0,t.jsx)(n.p,{children:"Prophet does not support autologging to prevent overwhelming the tracking server. Time series forecasting often involves training hundreds or thousands of models (e.g., one per product or location), which would create excessive load on the tracking server if autologging were enabled. Use manual logging with bulk APIs for large-scale forecasting workflows."})}),"\n",(0,t.jsx)(n.h2,{id:"why-mlflow--prophet",children:"Why MLflow + Prophet?"}),"\n",(0,t.jsx)(a.A,{features:[{icon:d.A,title:"Model Tracking",description:"Log Prophet models with parameters, cross-validation metrics, and forecast components for comprehensive experiment tracking."},{icon:c.A,title:"Experiment Comparison",description:"Compare different seasonality configurations, holiday effects, and hyperparameter combinations across forecasting experiments."},{icon:m.A,title:"Forecast Validation",description:"Integrate Prophet's cross-validation metrics directly into MLflow tracking for reproducible model evaluation."},{icon:p.A,title:"Model Registry",description:"Version and deploy Prophet forecasting models with MLflow's model registry and serving infrastructure."}]}),"\n",(0,t.jsx)(n.h2,{id:"basic-model-logging",children:"Basic Model Logging"}),"\n",(0,t.jsx)(n.p,{children:"Log Prophet models with MLflow to track forecasting experiments:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import mlflow\nimport mlflow.prophet\nimport pandas as pd\nfrom prophet import Prophet\nfrom prophet.diagnostics import cross_validation, performance_metrics\n\n# Load time series data (Prophet requires \'ds\' and \'y\' columns)\nurl = "https://raw.githubusercontent.com/facebook/prophet/main/examples/example_wp_log_peyton_manning.csv"\ndf = pd.read_csv(url)\n\nwith mlflow.start_run():\n    # Create and fit Prophet model\n    model = Prophet(\n        changepoint_prior_scale=0.05,\n        seasonality_prior_scale=10,\n        yearly_seasonality=True,\n        weekly_seasonality=True,\n    )\n    model.fit(df)\n\n    # Log model parameters\n    mlflow.log_params(\n        {\n            "changepoint_prior_scale": 0.05,\n            "seasonality_prior_scale": 10,\n            "yearly_seasonality": True,\n            "weekly_seasonality": True,\n        }\n    )\n\n    # Cross-validation\n    cv_results = cross_validation(\n        model,\n        initial="730 days",\n        period="180 days",\n        horizon="365 days",\n    )\n\n    # Log performance metrics\n    metrics = performance_metrics(cv_results)\n    mlflow.log_metrics(metrics[["mse", "rmse", "mae", "mape"]].mean().to_dict())\n\n    # Log model\n    mlflow.prophet.log_model(\n        pr_model=model, name="prophet_model", input_example=df[["ds"]].head()\n    )\n'})}),"\n",(0,t.jsx)(n.h2,{id:"cross-validation-tracking",children:"Cross-Validation Tracking"}),"\n",(0,t.jsx)(n.p,{children:"Prophet's cross-validation results integrate with MLflow for comprehensive forecast evaluation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def validate_prophet_model(model, df):\n    """Track cross-validation across multiple forecast horizons."""\n\n    with mlflow.start_run():\n        # Multiple validation configurations\n        cv_configs = [\n            {\n                "name": "short",\n                "initial": "365 days",\n                "period": "90 days",\n                "horizon": "90 days",\n            },\n            {\n                "name": "medium",\n                "initial": "730 days",\n                "period": "180 days",\n                "horizon": "180 days",\n            },\n            {\n                "name": "long",\n                "initial": "1095 days",\n                "period": "180 days",\n                "horizon": "365 days",\n            },\n        ]\n\n        for config in cv_configs:\n            cv_results = cross_validation(\n                model,\n                initial=config["initial"],\n                period=config["period"],\n                horizon=config["horizon"],\n            )\n\n            metrics = performance_metrics(cv_results)\n            avg_metrics = metrics[["mse", "rmse", "mae", "mape"]].mean()\n\n            # Log with horizon prefix\n            for metric, value in avg_metrics.items():\n                mlflow.log_metric(f"{config[\'name\']}_{metric}", value)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"hyperparameter-optimization",children:"Hyperparameter Optimization"}),"\n",(0,t.jsx)(n.p,{children:"Track Prophet hyperparameter tuning experiments with MLflow:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import optuna\n\n\ndef objective(trial, df):\n    """Optuna objective for Prophet hyperparameter tuning."""\n\n    with mlflow.start_run(nested=True):\n        # Define hyperparameter search space\n        params = {\n            "changepoint_prior_scale": trial.suggest_float(\n                "changepoint_prior_scale", 0.001, 0.5\n            ),\n            "seasonality_prior_scale": trial.suggest_float(\n                "seasonality_prior_scale", 0.01, 10\n            ),\n            "holidays_prior_scale": trial.suggest_float(\n                "holidays_prior_scale", 0.01, 10\n            ),\n            "seasonality_mode": trial.suggest_categorical(\n                "seasonality_mode", ["additive", "multiplicative"]\n            ),\n        }\n\n        # Train model\n        model = Prophet(**params)\n        model.fit(df)\n\n        # Cross-validation\n        cv_results = cross_validation(\n            model, initial="730 days", period="180 days", horizon="365 days"\n        )\n        metrics = performance_metrics(cv_results)\n        mape = metrics["mape"].mean()\n\n        # Log parameters and metrics\n        mlflow.log_params(params)\n        mlflow.log_metric("mape", mape)\n\n        return mape\n\n\n# Run optimization\nwith mlflow.start_run(run_name="Prophet HPO"):\n    study = optuna.create_study(direction="minimize")\n    study.optimize(lambda trial: objective(trial, df), n_trials=50)\n\n    # Log best parameters\n    mlflow.log_params({f"best_{k}": v for k, v in study.best_params.items()})\n    mlflow.log_metric("best_mape", study.best_value)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"model-registry-integration",children:"Model Registry Integration"}),"\n",(0,t.jsx)(n.p,{children:"Register Prophet models for version control and deployment:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from mlflow import MlflowClient\n\nclient = MlflowClient()\n\nwith mlflow.start_run():\n    # Train and log model\n    model = Prophet()\n    model.fit(df)\n\n    model_info = mlflow.prophet.log_model(\n        pr_model=model,\n        name="prophet_model",\n        registered_model_name="sales_forecast_model",\n    )\n\n    # Tag for deployment tracking\n    mlflow.set_tags(\n        {\n            "model_type": "prophet",\n            "forecast_horizon": "365_days",\n            "data_frequency": "daily",\n        }\n    )\n\n# Transition to production\nclient.transition_model_version_stage(\n    name="sales_forecast_model",\n    version=model_info.registered_model_version,\n    stage="Production",\n)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"model-loading-and-inference",children:"Model Loading and Inference"}),"\n",(0,t.jsx)(n.p,{children:"Load and use logged Prophet models:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Load as native Prophet model\nmodel_uri = "runs:/<run_id>/prophet_model"\nloaded_model = mlflow.prophet.load_model(model_uri)\n\n# Generate forecast\nfuture = loaded_model.make_future_dataframe(periods=365)\nforecast = loaded_model.predict(future)\n\n# Load as PyFunc for generic inference\npyfunc_model = mlflow.pyfunc.load_model(model_uri)\npredictions = pyfunc_model.predict(pd.DataFrame({"ds": future_dates}))\n'})}),"\n",(0,t.jsx)(n.h2,{id:"batch-forecasting-workflow",children:"Batch Forecasting Workflow"}),"\n",(0,t.jsx)(n.p,{children:"Track multiple Prophet models for hierarchical forecasting:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def train_hierarchical_forecasts(data_dict):\n    """Train separate Prophet models for multiple series."""\n\n    with mlflow.start_run(run_name="Hierarchical Forecasting"):\n        for series_name, series_data in data_dict.items():\n            with mlflow.start_run(run_name=f"Series_{series_name}", nested=True):\n                model = Prophet()\n                model.fit(series_data)\n\n                # Log series-specific info\n                mlflow.log_param("series_name", series_name)\n                mlflow.log_param("data_points", len(series_data))\n\n                # Cross-validation\n                cv_results = cross_validation(\n                    model, initial="365 days", period="90 days", horizon="180 days"\n                )\n                metrics = performance_metrics(cv_results)\n                mlflow.log_metrics(metrics[["mape", "rmse"]].mean().to_dict())\n\n                # Log model\n                mlflow.prophet.log_model(pr_model=model, name=f"model_{series_name}")\n'})}),"\n",(0,t.jsxs)(n.admonition,{title:"High-Volume Model Training",type:"tip",children:[(0,t.jsx)(n.p,{children:"When training many Prophet models (e.g., for thousands of products), use bulk logging to reduce tracking server load:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Collect metrics in batch\nmetrics_batch = {}\nparams_batch = {}\n\nfor series_name, series_data in data_dict.items():\n    model = Prophet()\n    model.fit(series_data)\n\n    # Collect metrics\n    cv_results = cross_validation(\n        model, initial="365 days", period="45 days", horizon="90 days"\n    )\n    perf_metrics = performance_metrics(cv_results)\n\n    metrics_batch[f"{series_name}_mape"] = perf_metrics["mape"].mean()\n    params_batch[f"{series_name}_n_points"] = len(series_data)\n\n# Bulk log after collection\nwith mlflow.start_run():\n    mlflow.log_metrics(metrics_batch)\n    mlflow.log_params(params_batch)\n'})})]}),"\n",(0,t.jsx)(n.h2,{id:"forecast-component-logging",children:"Forecast Component Logging"}),"\n",(0,t.jsx)(n.p,{children:"Log Prophet forecast components as artifacts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'with mlflow.start_run():\n    model = Prophet()\n    model.fit(df)\n\n    # Generate forecast\n    future = model.make_future_dataframe(periods=365)\n    forecast = model.predict(future)\n\n    # Log component plots\n    fig_components = model.plot_components(forecast)\n    mlflow.log_figure(fig_components, "forecast_components.png")\n\n    # Log forecast plot\n    fig_forecast = model.plot(forecast)\n    mlflow.log_figure(fig_forecast, "forecast_plot.png")\n\n    # Log model\n    mlflow.prophet.log_model(pr_model=model, name="prophet_model")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"learn-more",children:"Learn More"}),"\n",(0,t.jsxs)(l.A,{children:[(0,t.jsx)(s.A,{icon:p.A,title:"Model Registry",description:"Version and deploy Prophet models",href:"/ml/model-registry"}),(0,t.jsx)(s.A,{icon:c.A,title:"MLflow Tracking",description:"Track experiments and metrics",href:"/ml/tracking"}),(0,t.jsx)(s.A,{icon:d.A,title:"Model Evaluation",description:"Evaluate forecasting performance",href:"/ml/evaluation"})]})]})}function y(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(_,{...e})}):_(e)}},75689(e,n,r){r.d(n,{A:()=>s});var o=r(96540);let t=e=>{let n=e.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,n,r)=>r?r.toUpperCase():n.toLowerCase());return n.charAt(0).toUpperCase()+n.slice(1)},i=(...e)=>e.filter((e,n,r)=>!!e&&""!==e.trim()&&r.indexOf(e)===n).join(" ").trim();var a={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};let l=(0,o.forwardRef)(({color:e="currentColor",size:n=24,strokeWidth:r=2,absoluteStrokeWidth:t,className:l="",children:s,iconNode:d,...c},m)=>(0,o.createElement)("svg",{ref:m,...a,width:n,height:n,stroke:e,strokeWidth:t?24*Number(r)/Number(n):r,className:i("lucide",l),...!s&&!(e=>{for(let n in e)if(n.startsWith("aria-")||"role"===n||"title"===n)return!0})(c)&&{"aria-hidden":"true"},...c},[...d.map(([e,n])=>(0,o.createElement)(e,n)),...Array.isArray(s)?s:[s]])),s=(e,n)=>{let r=(0,o.forwardRef)(({className:r,...a},s)=>(0,o.createElement)(l,{ref:s,iconNode:n,className:i(`lucide-${t(e).replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()}`,`lucide-${e}`,r),...a}));return r.displayName=t(e),r}},44471(e,n,r){r.d(n,{A:()=>o});let o=(0,r(75689).A)("circle-check-big",[["path",{d:"M21.801 10A10 10 0 1 1 17 3.335",key:"yps3ct"}],["path",{d:"m9 11 3 3L22 4",key:"1pflzl"}]])},61878(e,n,r){r.d(n,{A:()=>o});let o=(0,r(75689).A)("git-branch",[["line",{x1:"6",x2:"6",y1:"3",y2:"15",key:"17qcm7"}],["circle",{cx:"18",cy:"6",r:"3",key:"1h7g24"}],["circle",{cx:"6",cy:"18",r:"3",key:"fqmcym"}],["path",{d:"M18 9a9 9 0 0 1-9 9",key:"n2h4wq"}]])},17133(e,n,r){r.d(n,{A:()=>o});let o=(0,r(75689).A)("package",[["path",{d:"M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",key:"1a0edw"}],["path",{d:"M12 22V12",key:"d0xqtd"}],["polyline",{points:"3.29 7 12 12 20.71 7",key:"ousv84"}],["path",{d:"m7.5 4.27 9 5.15",key:"1c824w"}]])},76316(e,n,r){r.d(n,{A:()=>o});let o=(0,r(75689).A)("trending-up",[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]])},33508(e,n,r){r.d(n,{A:()=>t});var o=r(74848);r(96540);function t({features:e,col:n=2}){return(0,o.jsx)("div",{className:"featureHighlights_Ardf",style:{gridTemplateColumns:`repeat(${n}, 1fr)`},children:e.map((e,n)=>(0,o.jsxs)("div",{className:"highlightItem_XPnN",children:[e.icon&&(0,o.jsx)("div",{className:"highlightIcon_SUR8",children:(0,o.jsx)(e.icon,{size:24})}),(0,o.jsxs)("div",{className:"highlightContent_d0XP",children:[(0,o.jsx)("h4",{children:e.title}),(0,o.jsx)("p",{children:e.description})]})]},n))})}},77541(e,n,r){r.d(n,{A:()=>d});var o=r(74848);r(96540);var t=r(95310),i=r(34164);let a="tileImage_O4So";var l=r(66497),s=r(92802);function d({icon:e,image:n,imageDark:r,imageWidth:d,imageHeight:c,iconSize:m=32,containerHeight:p,title:h,description:f,href:g,linkText:u="Learn more \u2192",className:_}){if(!e&&!n)throw Error("TileCard requires either an icon or image prop");let y=p?{height:`${p}px`}:{},v={};return d&&(v.width=`${d}px`),c&&(v.height=`${c}px`),(0,o.jsxs)(t.A,{href:g,className:(0,i.A)("tileCard_NHsj",_),children:[(0,o.jsx)("div",{className:"tileIcon_pyoR",style:y,children:e?(0,o.jsx)(e,{size:m}):r?(0,o.jsx)(s.A,{sources:{light:(0,l.default)(n),dark:(0,l.default)(r)},alt:h,className:a,style:v}):(0,o.jsx)("img",{src:(0,l.default)(n),alt:h,className:a,style:v})}),(0,o.jsx)("h3",{children:h}),(0,o.jsx)("p",{children:f}),(0,o.jsx)("div",{className:"tileLink_iUbu",children:u})]})}},10440(e,n,r){r.d(n,{A:()=>i});var o=r(74848);r(96540);var t=r(34164);function i({children:e,className:n}){return(0,o.jsx)("div",{className:(0,t.A)("tilesGrid_hB9N",n),children:e})}},28453(e,n,r){r.d(n,{R:()=>a,x:()=>l});var o=r(96540);let t={},i=o.createContext(t);function a(e){let n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);