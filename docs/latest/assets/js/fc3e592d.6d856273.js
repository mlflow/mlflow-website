"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8706],{11907:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/interface_1-eef793eaf139821002cfdb770dcd608d.png"},28261:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"flavors/chat-model-intro/index","title":"Tutorial: Getting Started with ChatModel","description":"Starting in MLflow 3.0.0, we recommend ResponsesAgent instead of ChatModel. See more details in the ResponsesAgent Introduction.","source":"@site/docs/genai/flavors/chat-model-intro/index.mdx","sourceDirName":"flavors/chat-model-intro","slug":"/flavors/chat-model-intro/","permalink":"/docs/latest/genai/flavors/chat-model-intro/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"genAISidebar","previous":{"title":"Custom App Development Guide","permalink":"/docs/latest/genai/flavors/custom-pyfunc-for-llms/notebooks/custom-pyfunc-advanced-llm"},"next":{"title":"Tutorial: Custom GenAI Models using ChatModel","permalink":"/docs/latest/genai/flavors/chat-model-guide/"}}');var l=o(74848),a=o(28453),s=o(49374),i=o(72839);const r={},d="Tutorial: Getting Started with ChatModel",c={},h=[{value:"What You&#39;ll Learn",id:"what-youll-learn",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Understanding ChatModel: Input/Output Mapping",id:"understanding-chatmodel-inputoutput-mapping",level:2},{value:"Building Your First ChatModel",id:"building-your-first-chatmodel",level:2},{value:"Building a ChatModel that Accepts Inference Parameters",id:"building-a-chatmodel-that-accepts-inference-parameters",level:2},{value:"Comparison to PyFunc",id:"comparison-to-pyfunc",level:2},{value:"Conclusion",id:"conclusion",level:2}];function m(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"tutorial-getting-started-with-chatmodel",children:"Tutorial: Getting Started with ChatModel"})}),"\n",(0,l.jsx)(n.admonition,{title:"attention",type:"warning",children:(0,l.jsxs)(n.p,{children:["Starting in MLflow 3.0.0, we recommend ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.ResponsesAgent",children:(0,l.jsx)(n.code,{children:"ResponsesAgent"})})," instead of ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.ChatModel",children:(0,l.jsx)(n.code,{children:"ChatModel"})}),". See more details in the ",(0,l.jsx)(n.a,{href:"/genai/flavors/responses-agent-intro",children:"ResponsesAgent Introduction"}),"."]})}),"\n",(0,l.jsxs)(n.p,{children:["MLflow's ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.ChatModel",children:(0,l.jsx)(n.code,{children:"ChatModel"})})," class provides a standardized way to create production-ready conversational AI models.\nThe resulting models are fully integrated with MLflow's tracking, evaluation, and lifecycle management capabilities. They can be shared\nwith others in the MLflow Model Registry, deployed as a REST API, or loaded in a notebook for interactive use. Furthermore, they are\ncompatible with the widely-adopted OpenAI chat API spec, making them easy to integrate with other AI systems and tools."]}),"\n",(0,l.jsxs)(n.p,{children:["If you're already familiar with ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.PythonModel",children:(0,l.jsx)(n.code,{children:"PythonModel"})}),", you might wonder why ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.ChatModel",children:(0,l.jsx)(n.code,{children:"ChatModel"})})," is needed.\nAs GenAI applications grow more complex, mapping inputs, outputs, and parameters with a custom ",(0,l.jsx)(n.code,{children:"PythonModel"})," can be challenging. ",(0,l.jsx)(n.code,{children:"ChatModel"}),"\nsimplifies this by offering a structured, OpenAI-compatible schema for conversational AI models."]}),"\n",(0,l.jsxs)(i.X,{children:[(0,l.jsx)("thead",{children:(0,l.jsxs)("tr",{children:[(0,l.jsx)("th",{}),(0,l.jsx)("th",{children:"ChatModel"}),(0,l.jsx)("th",{children:"PythonModel"})]})}),(0,l.jsxs)("tbody",{children:[(0,l.jsxs)("tr",{children:[(0,l.jsx)("td",{children:"When to use"}),(0,l.jsxs)("td",{children:["Use when you want to develop and deploy a conversational model with ",(0,l.jsx)(n.strong,{children:"standard"})," chat schema compatible with OpenAI spec."]}),(0,l.jsxs)("td",{children:["Use when you want ",(0,l.jsx)(n.strong,{children:"full control"})," over the model's interface or customize every aspect of your model's behavior."]})]}),(0,l.jsxs)("tr",{children:[(0,l.jsx)("td",{children:"Interface"}),(0,l.jsxs)("td",{children:[(0,l.jsx)(n.strong,{children:"Fixed"})," to OpenAI's chat schema."]}),(0,l.jsxs)("td",{children:[(0,l.jsx)(n.strong,{children:"Full control"})," over the model's input and output schema."]})]}),(0,l.jsxs)("tr",{children:[(0,l.jsx)("td",{children:"Setup"}),(0,l.jsxs)("td",{children:[(0,l.jsx)(n.strong,{children:"Quick"}),". Works out of the box for conversational applications, with pre-defined model signature and input example."]}),(0,l.jsxs)("td",{children:[(0,l.jsx)(n.strong,{children:"Custom"}),". You need to define model signature or input example yourself."]})]}),(0,l.jsxs)("tr",{children:[(0,l.jsx)("td",{children:"Complexity"}),(0,l.jsxs)("td",{children:[(0,l.jsx)(n.strong,{children:"Low"}),". Standardized interface simplified model deployment and integration."]}),(0,l.jsxs)("td",{children:[(0,l.jsx)(n.strong,{children:"High"}),". Deploying and integrating the custom PythonModel may not be straightforward. E.g., The model needs to handle Pandas DataFrames as MLflow converts input data to DataFrames before passing it to PythonModel."]})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"what-youll-learn",children:"What You'll Learn"}),"\n",(0,l.jsx)(n.p,{children:"This guide will take you through the basics of using the ChatModel API to define custom conversational AI models. In particular, you will learn:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["How to map your application logic to the ",(0,l.jsx)(n.code,{children:"ChatModel"}),"'s input/output schema"]}),"\n",(0,l.jsx)(n.li,{children:"How to use the pre-defined inference parameters supported by ChatModels"}),"\n",(0,l.jsxs)(n.li,{children:["How to pass custom parameters to a ChatModel using ",(0,l.jsx)(n.code,{children:"custom_inputs"})]}),"\n",(0,l.jsxs)(n.li,{children:["How ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.ChatModel",children:(0,l.jsx)(n.code,{children:"ChatModel"})})," compares to ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.PythonModel",children:(0,l.jsx)(n.code,{children:"PythonModel"})})," for defining custom chat models"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["To illustrate these points, this guide will walk you through building a custom ",(0,l.jsx)(n.code,{children:"ChatModel"}),", using a locally-hosted Ollama model as our example.\nThere is no built-in Ollama model flavor, so creating a custom ",(0,l.jsx)(n.code,{children:"ChatModel"})," provides a way to use MLflow's extensive tracking, evaluation, and lifecycle\nmanagement capabilities with Ollama models."]}),"\n",(0,l.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Familiarity with MLflow logging APIs and GenAI concepts."}),"\n",(0,l.jsxs)(n.li,{children:["MLflow version 2.17.0 or higher installed for use of ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.ChatModel",children:(0,l.jsx)(n.code,{children:"ChatModel"})}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"understanding-chatmodel-inputoutput-mapping",children:"Understanding ChatModel: Input/Output Mapping"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.ChatModel",children:(0,l.jsx)(n.code,{children:"mlflow.pyfunc.ChatModel"})})," interface sits between your application and MLflow's ecosystem, providing\na layer of standardization that makes it easier to integrate your application with MLflow's other features and to deploy your model in an accessible, production-ready format."]}),"\n",(0,l.jsxs)(n.p,{children:["To that end, when defining a custom ",(0,l.jsx)(n.code,{children:"ChatModel"}),", the key task is to map your application's logic to the ",(0,l.jsx)(n.code,{children:"ChatModel"}),"'s standardized interface.\n",(0,l.jsx)(n.em,{children:"This mapping exercise is the fundamental part of creating a custom"})," ",(0,l.jsx)(n.code,{children:"ChatModel"}),"."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.img,{alt:"ChatModel Interface",src:o(11907).A+"",width:"6618",height:"1901"})}),"\n",(0,l.jsxs)(n.p,{children:["When using a custom ChatModel, the ",(0,l.jsx)(n.code,{children:"predict"})," method expects standardized inputs that look like this:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'input = {\n    "messages": [{"role": "user", "content": "What is MLflow?"}],\n    "max_tokens": 25,\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["with a ",(0,l.jsx)(n.code,{children:"messages"})," key containing a list of messages, and optional inference parameters such as ",(0,l.jsx)(n.code,{children:"max_tokens"}),", ",(0,l.jsx)(n.code,{children:"temperature"}),", ",(0,l.jsx)(n.code,{children:"top_p"}),", and ",(0,l.jsx)(n.code,{children:"stop"}),".\nYou can find details of the full chat request object ",(0,l.jsx)(n.a,{href:"https://mlflow.org/docs/latest/python_api/mlflow.types.html#mlflow.types.llm.ChatCompletionRequest",children:"here"}),"."]}),"\n",(0,l.jsx)(n.p,{children:"The output is also returned in a standardized format that looks like this:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'{\n    "choices": [\n        {\n            "index": 0,\n            "message": {\n                "role": "assistant",\n                "content": "MLflow is an open-source platform for machine learning (ML) and artificial intelligence (AI). It\'s designed to manage,",\n            },\n            "finish_reason": "stop",\n        }\n    ],\n    "model": "llama3.2:1b",\n    "object": "chat.completion",\n    "created": 1729190863,\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["You can find details of the full chat response object ",(0,l.jsx)(s.B,{fn:"mlflow.types.llm.ChatCompletionResponse",children:"here"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["These input/output schemas are compatible with the widely-adopted OpenAI spec, making ",(0,l.jsx)(n.code,{children:"ChatModel"})," s easy to use in a wide variety of contexts."]}),"\n",(0,l.jsxs)(n.p,{children:["To demonstrate this mapping process, we will show how to use the ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.ChatModel",children:(0,l.jsx)(n.code,{children:"mlflow.pyfunc.ChatModel"})})," class to log\nMeta's Llama 3.2 1B model via the Ollama llm client, which does not have a native MLflow flavor."]}),"\n",(0,l.jsx)(n.h2,{id:"building-your-first-chatmodel",children:"Building Your First ChatModel"}),"\n",(0,l.jsxs)(n.p,{children:["In this section, we will wrap a locally-hosted Ollama model with the ",(0,l.jsx)(n.code,{children:"ChatModel"})," interface.\nWe will build a simplified version showing how to handle inputs and outputs, and then we will\nshow how to handle inference parameters such as ",(0,l.jsx)(n.code,{children:"max_tokens"})," and ",(0,l.jsx)(n.code,{children:"temperature"}),"."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Setup: Install Ollama and download the model"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Install Ollama from ",(0,l.jsx)(n.a,{href:"https://ollama.com",children:"here"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Once Ollama is installed and running, download the Llama 3.2 1B model by running ",(0,l.jsx)(n.code,{children:"ollama pull llama3.2:1b"})]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["You can validate that the model is downloaded and available on your system with ",(0,l.jsx)(n.code,{children:"ollama run llama3.2:1b"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"> ollama run llama3.2:1b\n\n>>> Hello world!\nHello! It's great to see you're starting the day with a cheerful greeting. How can I assist you today?\n>>> Send a message (/? for help)\n"})}),"\n",(0,l.jsxs)(n.p,{children:["We will use the ",(0,l.jsx)(n.code,{children:"ollama-python"})," library to interface with the Ollama model. Install it to your Python environment with ",(0,l.jsx)(n.code,{children:"pip install ollama"}),".\nAlso, install ",(0,l.jsx)(n.code,{children:"mlflow"})," with ",(0,l.jsx)(n.code,{children:"pip install mlflow"}),"."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Using the Ollama Python library"})}),"\n",(0,l.jsx)(n.p,{children:"In order to map the Ollama input/output schema to the ChatModel input/output schema, we first need to understand what kinds of inputs and outputs\nthe Ollama model expects and returns. Here's how to query the model with a simple prompt:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'import ollama\nfrom ollama import Options\nfrom rich import print\n\nresponse = ollama.chat(\n    model="llama3.2:1b",\n    messages=[\n        {\n            "role": "user",\n            "content": "What is MLflow Tracking?",\n        }\n    ],\n    options=Options({"num_predict": 25}),\n)\n\nprint(response)\n'})}),"\n",(0,l.jsx)(n.p,{children:"Which returns the following output:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"{\n    'model': 'llama3.2:1b',\n    'created_at': '2024-11-04T12:47:53.075714Z',\n    'message': {\n        'role': 'assistant',\n        'content': 'MLflow Tracking is an open-source platform for managing, monitoring, and deploying machine learning (ML) models. It provides a'\n    },\n    'done_reason': 'length',\n    'done': True,\n    'total_duration': 1201354125,\n    'load_duration': 819609167,\n    'prompt_eval_count': 31,\n    'prompt_eval_duration': 41812000,\n    'eval_count': 25,\n    'eval_duration': 337872000\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Here are a few things to note about the Ollama inputs and outputs:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["The ",(0,l.jsx)(n.code,{children:"messages"})," argument expected by the ",(0,l.jsx)(n.code,{children:"ollama.chat"})," method is a list of dictionaries with ",(0,l.jsx)(n.code,{children:"role"})," and ",(0,l.jsx)(n.code,{children:"content"})," keys.\nWe will need to convert the list of ",(0,l.jsx)(n.code,{children:"ChatMessage"})," objects expected by the ChatModel API to a list of dictionaries."]}),"\n",(0,l.jsxs)(n.li,{children:["Inference parameters are passed to Ollama via the ",(0,l.jsx)(n.code,{children:"options"})," argument, which is a dictionary of parameters. Furthermore,\nas we can see based on ",(0,l.jsx)(n.code,{children:"num_predict"}),", the parameter names are different from those expected by ChatModel. We will need to map\nthe ChatModel inference parameters to the Ollama options."]}),"\n",(0,l.jsxs)(n.li,{children:["The output is structured differently from the ",(0,l.jsx)(n.code,{children:"ChatModel"})," output schema. We will need to map this to the ChatModel output schema."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Ollama ChatModel Version 1: Chat only"})}),"\n",(0,l.jsxs)(n.p,{children:["Let's start with a simple version of a custom ",(0,l.jsx)(n.code,{children:"ChatModel"})," that handles inputs/output messages but does not yet handle inference parameters.\nTo accomplish this, we need to:"]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Define a class that extends ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.ChatModel",children:(0,l.jsx)(n.code,{children:"mlflow.pyfunc.ChatModel"})})]}),"\n",(0,l.jsxs)(n.li,{children:["Implement the ",(0,l.jsx)(n.code,{children:"load_context"})," method, which will handle the initialization of the Ollama client"]}),"\n",(0,l.jsxs)(n.li,{children:["Implement the ",(0,l.jsx)(n.code,{children:"predict"})," method, which will handle the input/output mapping"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Most of the customization, at least in this simple version, will occur in the ",(0,l.jsx)(n.code,{children:"predict"})," method. When implementing the ",(0,l.jsx)(n.code,{children:"predict"})," method,\nwe make use of the following standardized inputs:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"messages"}),": a list of ",(0,l.jsx)(n.code,{children:"ChatMessage"})," objects"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"params"}),": a ",(0,l.jsx)(n.code,{children:"ChatParams"})," object, which contains the inference parameters"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["And we need to return a ",(0,l.jsx)(n.code,{children:"ChatCompletionResponse"})," object, which is a dataclass made up of a list of ",(0,l.jsx)(n.code,{children:"ChatChoice"})," objects, along with (optional) usage data and other metadata."]}),"\n",(0,l.jsx)(n.p,{children:"These are what we must map to the Ollama inputs and outputs. Here's a simplified version that, for now, only handles the input/output messages:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'# if you are using a jupyter notebook\n# %%writefile ollama_model.py\nfrom mlflow.pyfunc import ChatModel\nfrom mlflow.types.llm import ChatMessage, ChatCompletionResponse, ChatChoice\nfrom mlflow.models import set_model\nimport ollama\n\n\nclass SimpleOllamaModel(ChatModel):\n    def __init__(self):\n        self.model_name = "llama3.2:1b"\n        self.client = None\n\n    def load_context(self, context):\n        self.client = ollama.Client()\n\n    def predict(self, context, messages, params=None):\n        # Prepare the messages for Ollama\n        ollama_messages = [msg.to_dict() for msg in messages]\n\n        # Call Ollama\n        response = self.client.chat(model=self.model_name, messages=ollama_messages)\n\n        # Prepare and return the ChatCompletionResponse\n        return ChatCompletionResponse(\n            choices=[{"index": 0, "message": response["message"]}],\n            model=self.model_name,\n        )\n\n\nset_model(SimpleOllamaModel())\n'})}),"\n",(0,l.jsxs)(n.p,{children:["In the above code, we mapped the ",(0,l.jsx)(n.code,{children:"ChatModel"})," inputs to the Ollama inputs, and the Ollama output back to the ",(0,l.jsx)(n.code,{children:"ChatModel"})," output schema. More specifically:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["The ",(0,l.jsx)(n.code,{children:"messages"})," key in the ",(0,l.jsx)(n.code,{children:"ChatModel"})," input schema is a list of ",(0,l.jsx)(n.code,{children:"ChatMessage"})," objects. We converted this to a list of dictionaries with ",(0,l.jsx)(n.code,{children:"role"})," and\n",(0,l.jsx)(n.code,{children:"content"})," keys, which is the expected input format for Ollama."]}),"\n",(0,l.jsxs)(n.li,{children:["The ",(0,l.jsx)(n.code,{children:"ChatCompletionResponse"})," that the ",(0,l.jsx)(n.code,{children:"predict"})," method returns must be created using the ",(0,l.jsx)(n.code,{children:"ChatCompletionResponse"})," dataclass, but the nested message and\nchoice data can be provided as dictionaries that match the expected schema. MLflow will automatically convert these dictionaries to the appropriate dataclass\nobjects. In our case, we created a ",(0,l.jsx)(n.code,{children:"ChatCompletionResponse"})," but provided the choices and messages as dictionaries."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["In a notebook environment, we can save the model to a file called ",(0,l.jsx)(n.code,{children:"ollama_model.py"})," with the ",(0,l.jsx)(n.code,{children:"%%writefile"})," magic command and call ",(0,l.jsx)(n.code,{children:"set_model(SimpleOllamaModel())"}),'.\nThis is the "models from code" approach to model logging, which you can read more about ',(0,l.jsx)(n.a,{href:"/ml/model/models-from-code",children:"here"}),"."]}),"\n",(0,l.jsx)(n.p,{children:"Now we can log this model to MLflow as follows, passing the path to the file containing the model definition we just created:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'import mlflow\n\nmlflow.set_experiment("chatmodel-quickstart")\ncode_path = "ollama_model.py"\n\nwith mlflow.start_run():\n    model_info = mlflow.pyfunc.log_model(\n        name="ollama_model",\n        python_model=code_path,\n        input_example={\n            "messages": [{"role": "user", "content": "Hello, how are you?"}]\n        },\n    )\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Again, we used the models-from-code approach to log the model, so we passed the path to the file containing our model definition to the ",(0,l.jsx)(n.code,{children:"python_model"})," parameter.\nNow we can load the model and try it out:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'loaded_model = mlflow.pyfunc.load_model(model_info.model_uri)\n\nresult = loaded_model.predict(\n    data={\n        "messages": [{"role": "user", "content": "What is MLflow?"}],\n        "max_tokens": 25,\n    }\n)\nprint(result)\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'{\n    "choices": [\n        {\n            "index": 0,\n            "message": {\n                "role": "assistant",\n                "content": "MLflow is an open-source platform for model deployment, monitoring, and tracking. It was created by Databricks, a cloud-based data analytics company, in collaboration with The Data Science Experience (TDEE), a non-profit organization that focuses on providing high-quality, free machine learning resources.\\n\\nMLflow allows users to build, train, and deploy machine learning models in various frameworks, such as TensorFlow, PyTorch, and scikit-learn. It provides a unified platform for model development, deployment, and tracking across different environments, including local machines, cloud platforms (e.g., AWS), and edge devices.\\n\\nSome key features of MLflow include:\\n\\n1. **Model versioning**: Each time a model is trained or deployed, it generates a unique version number. This allows users to track changes, identify conflicts, and manage multiple versions.\\n2. **Model deployment**: MLflow provides tools for deploying models in various environments, including Docker containers, Kubernetes, and cloud platforms (e.g., AWS).\\n3. **Monitoring and logging**: The platform includes built-in monitoring and logging capabilities to track model performance, errors, and other metrics.\\n4. **Integration with popular frameworks**: MLflow integrates with popular machine learning frameworks, making it easy to incorporate the platform into existing workflows.\\n5. **Collaboration and sharing**: MLflow allows multiple users to collaborate on models and tracks changes in real-time.\\n\\nMLflow has several benefits, including:\\n\\n1. **Improved model management**: The platform provides a centralized view of all models, allowing for better model tracking and management.\\n2. **Increased collaboration**: MLflow enables team members to work together on machine learning projects more effectively.\\n3. **Better model performance monitoring**: The platform offers real-time insights into model performance, helping users identify issues quickly.\\n4. **Simplified model deployment**: MLflow makes it easy to deploy models in various environments, reducing the complexity of model deployment.\\n\\nOverall, MLflow is a powerful tool for managing and deploying machine learning models, providing a comprehensive platform for model development, tracking, and collaboration.",\n            },\n            "finish_reason": "stop",\n        }\n    ],\n    "model": "llama3.2:1b",\n    "object": "chat.completion",\n    "created": 1730739510,\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Now we have received a chat response in a standardized, OpenAI-compatible format. But something is wrong:\neven though we set ",(0,l.jsx)(n.code,{children:"max_tokens"})," to 25, the response is well over 25 tokens! Why is this?"]}),"\n",(0,l.jsx)(n.p,{children:"We have not yet handled the inference parameters in our custom ChatModel: in addition to mapping the input/output\nmessages between the ChatModel and Ollama formats, we also need to map the inference parameters between the two formats.\nWe will address this in the next version of our custom ChatModel."}),"\n",(0,l.jsx)(n.h2,{id:"building-a-chatmodel-that-accepts-inference-parameters",children:"Building a ChatModel that Accepts Inference Parameters"}),"\n",(0,l.jsxs)(n.p,{children:["Most LLMs support inference parameters that control how the response is generated, such as ",(0,l.jsx)(n.code,{children:"max_tokens"}),", which limits the number\nof tokens in the response, or ",(0,l.jsx)(n.code,{children:"temperature"}),', which adjusts the "creativity" of the response. The ChatModel API includes built-in support\nfor many of the most commonly-used inference parameters, and we will see how to configure and use them in this section.']}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Passing Parameters to a ChatModel"})}),"\n",(0,l.jsx)(n.p,{children:"When using a ChatModel, parameters are passed alongside messages in the input:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'result = model.predict(\n    {\n        "messages": [{"role": "user", "content": "Write a story"}],\n        "max_tokens": 100,\n        "temperature": 0.7,\n    }\n)\n'})}),"\n",(0,l.jsxs)(n.p,{children:["You can find the full list of supported parameters ",(0,l.jsx)(s.B,{fn:"mlflow.types.llm.ChatParams",children:"here"}),".\nFurthermore, you can pass arbitrary additional parameters to a ChatModel via the ",(0,l.jsx)(n.code,{children:"custom_inputs"})," key in the input, which we will cover in more\ndetail in the next section."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Comparison to Parameter Handling in Custom PyFunc Models"})}),"\n",(0,l.jsxs)(n.p,{children:["If you're familiar with configuring inference parameters for ",(0,l.jsx)(n.a,{href:"https://mlflow.org/blog/custom-pyfunc#parameterizing-the-custom-model",children:"PyFunc models"}),",\nyou will notice some key differences in how ChatModel handles parameters:"]}),"\n",(0,l.jsxs)(i.X,{children:[(0,l.jsx)("thead",{children:(0,l.jsxs)("tr",{children:[(0,l.jsx)("th",{children:"ChatModel"}),(0,l.jsx)("th",{children:"PyFunc"})]})}),(0,l.jsxs)("tbody",{children:[(0,l.jsxs)("tr",{children:[(0,l.jsxs)("td",{children:["Parameters are part of the ",(0,l.jsx)(n.code,{children:"data"})," dictionary passed to ",(0,l.jsx)(n.code,{children:"predict"}),", which also includes the ",(0,l.jsx)(n.code,{children:"messages"})," key"]}),(0,l.jsxs)("td",{children:["Parameters are passed to ",(0,l.jsx)(n.code,{children:"predict"})," as ",(0,l.jsx)(n.code,{children:"params"})," keyword argument"]})]}),(0,l.jsxs)("tr",{children:[(0,l.jsxs)("td",{children:["Commonly-used chat model parameters (e.g. ",(0,l.jsx)(n.code,{children:"max_tokens"}),", ",(0,l.jsx)(n.code,{children:"temperature"}),", ",(0,l.jsx)(n.code,{children:"top_p"}),") are pre-defined in the ChatModel class"]}),(0,l.jsx)("td",{children:"Parameters are chosen and configured by the developer"})]}),(0,l.jsxs)("tr",{children:[(0,l.jsx)("td",{children:"Model signature is automatically configured to support the common chat model parameters"}),(0,l.jsx)("td",{children:"Parameters must be explicitly defined in the model signature"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:"In short, ChatModels make it easy to configure and use inference parameters, while also providing a standardized,\nOpenAI-compatible output format, but at the cost of some flexibility."}),"\n",(0,l.jsx)(n.p,{children:"Now, let's configure our custom ChatModel to handle inference parameters."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Ollama ChatModel Version 2: Chat with inference parameters"})}),"\n",(0,l.jsxs)(n.p,{children:["Setting up a ChatModel with inference parameters is straightforward: just like with the input messages,\nwe need to map the inference parameters to the format expected by the Ollama client. In the Ollama client,\ninference parameters are passed to the model as an ",(0,l.jsx)(n.code,{children:"options"})," dictionary. When defining our custom ChatModel,\nwe can access the inference parameters passed to ",(0,l.jsx)(n.code,{children:"predict"})," via the ",(0,l.jsx)(n.code,{children:"params"})," keyword argument.\nOur job is to map the predict method's ",(0,l.jsx)(n.code,{children:"params"})," dictionary to the Ollama client's ",(0,l.jsx)(n.code,{children:"options"})," dictionary.\nYou can find the list of options supported by Ollama ",(0,l.jsx)(n.a,{href:"https://github.com/ollama/ollama/blob/main/docs/api.md#generate-request-with-options",children:"here"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'# if you are using a jupyter notebook\n# %%writefile ollama_model.py\n\nimport mlflow\nfrom mlflow.pyfunc import ChatModel\nfrom mlflow.types.llm import ChatMessage, ChatCompletionResponse, ChatChoice\nfrom mlflow.models import set_model\nimport ollama\nfrom ollama import Options\n\n\nclass OllamaModelWithMetadata(ChatModel):\n    def __init__(self):\n        self.model_name = None\n        self.client = None\n\n    def load_context(self, context):\n        self.model_name = "llama3.2:1b"\n        self.client = ollama.Client()\n\n    def _prepare_options(self, params):\n        # Prepare options from params\n        options = {}\n        if params:\n            if params.max_tokens is not None:\n                options["num_predict"] = params.max_tokens\n            if params.temperature is not None:\n                options["temperature"] = params.temperature\n            if params.top_p is not None:\n                options["top_p"] = params.top_p\n            if params.stop is not None:\n                options["stop"] = params.stop\n\n            if params.custom_inputs is not None:\n                options["seed"] = int(params.custom_inputs.get("seed", None))\n\n        return Options(options)\n\n    def predict(self, context, messages, params=None):\n        ollama_messages = [\n            {"role": msg.role, "content": msg.content} for msg in messages\n        ]\n        options = self._prepare_options(params)\n\n        # Call Ollama\n        response = self.client.chat(\n            model=self.model_name, messages=ollama_messages, options=options\n        )\n\n        # Prepare the ChatCompletionResponse\n        return ChatCompletionResponse(\n            choices=[{"index": 0, "message": response["message"]}],\n            model=self.model_name,\n        )\n\n\nset_model(OllamaModelWithMetadata())\n'})}),"\n",(0,l.jsx)(n.p,{children:"Here's what we changed from the previous version:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["We mapped ",(0,l.jsx)(n.code,{children:"max_tokens"}),", ",(0,l.jsx)(n.code,{children:"temperature"}),", ",(0,l.jsx)(n.code,{children:"top_p"}),", and ",(0,l.jsx)(n.code,{children:"stop"})," from the ",(0,l.jsx)(n.code,{children:"params"})," dictionary to ",(0,l.jsx)(n.code,{children:"num_predict"}),",\n",(0,l.jsx)(n.code,{children:"temperature"}),", ",(0,l.jsx)(n.code,{children:"top_p"}),", and ",(0,l.jsx)(n.code,{children:"stop"})," in the Ollama client's ",(0,l.jsx)(n.code,{children:"options"})," dictionary (note the different parameter name\nfor ",(0,l.jsx)(n.code,{children:"max_tokens"})," expected by Ollama)"]}),"\n",(0,l.jsxs)(n.li,{children:["We passed the ",(0,l.jsx)(n.code,{children:"options"})," dictionary to the Ollama client's ",(0,l.jsx)(n.code,{children:"chat"})," method. Note that we created a new private method,\n",(0,l.jsx)(n.code,{children:"_prepare_options"}),", to handle the mapping from ",(0,l.jsx)(n.code,{children:"params"})," to ",(0,l.jsx)(n.code,{children:"options"}),". Additional methods can be added to a custom\n",(0,l.jsx)(n.code,{children:"ChatModel"})," to keep code clean and organized while handling custom logic."]}),"\n",(0,l.jsxs)(n.li,{children:["We checked the ",(0,l.jsx)(n.code,{children:"custom_inputs"})," key in the ",(0,l.jsx)(n.code,{children:"params"})," dictionary for a ",(0,l.jsx)(n.code,{children:"seed"})," value\u2014we'll cover this in more detail\nin the next section."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Now we can log this model to MLflow, load it, and try it out in the same way as before:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'code_path = "ollama_model.py"\n\nwith mlflow.start_run():\n    model_info = mlflow.pyfunc.log_model(\n        name="ollama_model",\n        python_model=code_path,\n        input_example={\n            "messages": [{"role": "user", "content": "Hello, how are you?"}]\n        },\n    )\n\nloaded_model = mlflow.pyfunc.load_model(model_info.model_uri)\n\nresult = loaded_model.predict(\n    data={\n        "messages": [{"role": "user", "content": "What is MLflow?"}],\n        "max_tokens": 25,\n    }\n)\nprint(result)\n'})}),"\n",(0,l.jsx)(n.p,{children:"Which returns:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'{\n    "choices": [\n        {\n            "index": 0,\n            "message": {\n                "role": "assistant",\n                "content": "MLflow is an open-source platform that provides a set of tools for managing and tracking machine learning (ML) model deployments,",\n            },\n            "finish_reason": "stop",\n        }\n    ],\n    "model": "llama3.2:1b",\n    "object": "chat.completion",\n    "created": 1730724514,\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Now that we have appropriately mapped ",(0,l.jsx)(n.code,{children:"max_tokens"})," from the ChatModel input schema to the Ollama client's ",(0,l.jsx)(n.code,{children:"num_predict"})," parameter,\nwe receive a response with the expected number of tokens."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Passing Custom Parameters"})}),"\n",(0,l.jsxs)(n.p,{children:["What if we want to pass a custom parameter that is not included in the list of built-in inference parameters? The ChatModel API provides\na way to do this via the ",(0,l.jsx)(n.code,{children:"custom_inputs"})," key, which accepts a dictionary of key-value pairs that are passed through to the model as-is.\nBoth the keys and values must be strings, so it might be necessary to handle type conversions in the ",(0,l.jsx)(n.code,{children:"predict"})," method. In the above example,\nwe configured the Ollama model to use a custom ",(0,l.jsx)(n.code,{children:"seed"})," value by adding a ",(0,l.jsx)(n.code,{children:"seed"})," key to the ",(0,l.jsx)(n.code,{children:"custom_inputs"})," dictionary:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'if params.custom_inputs is not None:\n    options["seed"] = int(params.custom_inputs.get("seed", None))\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Because we included this, we can now pass a ",(0,l.jsx)(n.code,{children:"seed"})," value via the ",(0,l.jsx)(n.code,{children:"custom_inputs"})," key in the ",(0,l.jsx)(n.code,{children:"predict"})," method. If you call ",(0,l.jsx)(n.code,{children:"predict"}),"\nmultiple times with the same seed value, you will always receive the same response."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'result = loaded_model.predict(\n    data={\n        "messages": [{"role": "user", "content": "What is MLflow?"}],\n        "max_tokens": 25,\n        "custom_inputs": {"seed": "321"},\n    }\n)\n\nprint(result)\n'})}),"\n",(0,l.jsx)(n.p,{children:"Which returns:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'{\n    "choices": [\n        {\n            "index": 0,\n            "message": {\n                "role": "assistant",\n                "content": "MLflow is an open-source software framework used for machine learning model management, monitoring, and deployment. It\'s designed to provide",\n            },\n            "finish_reason": "stop",\n        }\n    ],\n    "model": "llama3.2:1b",\n    "object": "chat.completion",\n    "created": 1730724533,\n}\n'})}),"\n",(0,l.jsxs)(n.admonition,{type:"tip",children:[(0,l.jsx)(n.p,{children:"Using vs. Defining ChatModels"}),(0,l.jsxs)(n.p,{children:["There's an important distinction between how you pass data when ",(0,l.jsx)(n.em,{children:"using"})," a ChatModel versus how you access that data when ",(0,l.jsx)(n.em,{children:"defining"})," one."]}),(0,l.jsxs)(n.p,{children:["When ",(0,l.jsx)(n.em,{children:"using"})," an instantiated ChatModel, all the arguments\u2014messages, parameters, etc.\u2014are passed to the ",(0,l.jsx)(n.code,{children:"predict"})," method as a single dictionary."]}),(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'model.predict({"messages": [{"role": "user", "content": "Hello"}], "temperature": 0.7})\n'})}),(0,l.jsxs)(n.p,{children:["When ",(0,l.jsx)(n.em,{children:"defining"})," the custom ChatModel's ",(0,l.jsx)(n.code,{children:"predict"})," method, on the other hand, we access the data through separate ",(0,l.jsx)(n.code,{children:"messages"})," and ",(0,l.jsx)(n.code,{children:"params"})," arguments,\nwhere ",(0,l.jsx)(n.code,{children:"messages"})," is a list of ",(0,l.jsx)(n.code,{children:"ChatMessage"})," objects and ",(0,l.jsx)(n.code,{children:"params"})," is a ",(0,l.jsx)(n.code,{children:"ChatParams"})," object. Understanding this distinction\u2014unified input for users,\nstructured access for developers\u2014is important to working effectively with ChatModels."]})]}),"\n",(0,l.jsx)(n.h2,{id:"comparison-to-pyfunc",children:"Comparison to PyFunc"}),"\n",(0,l.jsxs)(n.p,{children:["To illustrate some of the benefits and trade-offs of setting up a chat model via the ",(0,l.jsx)(n.code,{children:"ChatModel"})," API vs. the ",(0,l.jsx)(n.code,{children:"PythonModel"})," API,\nlet's see what the above model would look like if we implemented it as a ",(0,l.jsx)(n.code,{children:"PythonModel"}),"."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Ollama Model Version 3: Custom PyFunc Model"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'# if you are using a jupyter notebook\n# %%writefile ollama_pyfunc_model.py\n\nimport mlflow\nfrom mlflow.pyfunc import PythonModel\nfrom mlflow.types.llm import (\n    ChatCompletionRequest,\n    ChatCompletionResponse,\n    ChatMessage,\n    ChatChoice,\n)\nfrom mlflow.models import set_model\nimport ollama\nfrom ollama import Options\nimport pandas as pd\nfrom typing import List, Dict\n\n\nclass OllamaPyfunc(PythonModel):\n    def __init__(self):\n        self.model_name = None\n        self.client = None\n\n    def load_context(self, context):\n        self.model_name = "llama3.2:1b"\n        self.client = ollama.Client()\n\n    def _prepare_options(self, params):\n        options = {}\n        if params:\n            if "max_tokens" in params:\n                options["num_predict"] = params["max_tokens"]\n            if "temperature" in params:\n                options["temperature"] = params["temperature"]\n            if "top_p" in params:\n                options["top_p"] = params["top_p"]\n            if "stop" in params:\n                options["stop"] = params["stop"]\n            if "seed" in params:\n                options["seed"] = params["seed"]\n\n        return Options(options)\n\n    def predict(self, context, model_input, params=None):\n        if isinstance(model_input, (pd.DataFrame, pd.Series)):\n            messages = model_input.to_dict(orient="records")[0]["messages"]\n        else:\n            messages = model_input.get("messages", [])\n\n        options = self._prepare_options(params)\n        ollama_messages = [\n            {"role": msg["role"], "content": msg["content"]} for msg in messages\n        ]\n\n        response = self.client.chat(\n            model=self.model_name, messages=ollama_messages, options=options\n        )\n\n        chat_response = ChatCompletionResponse(\n            choices=[\n                ChatChoice(\n                    index=0,\n                    message=ChatMessage(\n                        role="assistant", content=response["message"]["content"]\n                    ),\n                )\n            ],\n            model=self.model_name,\n        )\n\n        return chat_response.to_dict()\n\n\nset_model(OllamaPyfunc())\n'})}),"\n",(0,l.jsxs)(n.p,{children:["This looks quite similar to how we defined our ",(0,l.jsx)(n.code,{children:"ChatModel"})," above, and you could in fact use this ",(0,l.jsx)(n.code,{children:"PythonModel"})," to serve the same Ollama model.\nHowever, there are some important differences:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"We had to handle the input data as a pandas DataFrame, even though the input is ultimately just a list of messages."}),"\n",(0,l.jsxs)(n.li,{children:["Instead of receiving the inference parameters as a pre-configured ",(0,l.jsx)(n.code,{children:"ChatParams"})," object, receive a ",(0,l.jsx)(n.code,{children:"params"})," dictionary. One consequence of\nthis is that we did not have to treat ",(0,l.jsx)(n.code,{children:"seed"})," any differently from the other inference parameters: they're ",(0,l.jsx)(n.em,{children:"all"})," custom parameters in the\n",(0,l.jsx)(n.code,{children:"PythonModel"})," API."]}),"\n",(0,l.jsxs)(n.li,{children:["We had to call ",(0,l.jsx)(n.code,{children:"chat_response.to_dict()"})," to convert the ",(0,l.jsx)(n.code,{children:"ChatCompletionResponse"})," object to a dictionary rather than a ",(0,l.jsx)(n.code,{children:"ChatCompletionResponse"}),"\nobject. This is handled automatically by ",(0,l.jsx)(n.code,{children:"ChatModel"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Some of the biggest differences come up when it's time to log the model:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'code_path = "ollama_pyfunc_model.py"\n\nparams = {\n    "max_tokens": 25,\n    "temperature": 0.5,\n    "top_p": 0.5,\n    "stop": ["\\n"],\n    "seed": 123,\n}\nrequest = {"messages": [{"role": "user", "content": "What is MLflow?"}]}\n\nwith mlflow.start_run():\n    model_info = mlflow.pyfunc.log_model(\n        name="ollama_pyfunc_model",\n        python_model=code_path,\n        input_example=(request, params),\n    )\n'})}),"\n",(0,l.jsxs)(n.p,{children:["With a custom ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.PythonModel",children:(0,l.jsx)(n.code,{children:"PythonModel"})}),", we need to manually define\nthe input example so that a model signature can be inferred using the example. This is a significant difference\nfrom the ChatModel API, which automatically configures a signature that conforms to the standard OpenAI-compatible\ninput/output/parameter schemas.\nTo learn more about auto inference of model signature based on an input example, see the\n",(0,l.jsx)(n.a,{href:"/ml/model/signatures#automatic-signature-inference",children:"GenAI model signature example"})," section for details."]}),"\n",(0,l.jsxs)(n.p,{children:["There is also one notable difference in how we call the loaded model's ",(0,l.jsx)(n.code,{children:"predict"})," method: parameters are passed as\na dictionary via the ",(0,l.jsx)(n.code,{children:"params"})," keyword argument, rather than in the dictionary containing the messages."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'loaded_model = mlflow.pyfunc.load_model(model_info.model_uri)\n\nresult = loaded_model.predict(\n    data={"messages": [{"role": "user", "content": "What is MLflow?"}]},\n    params={"max_tokens": 25, "seed": 42},\n)\nprint(result)\n'})}),"\n",(0,l.jsx)(n.p,{children:"Which returns:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'{\n    "choices": [\n        {\n            "index": 0,\n            "message": {\n                "role": "assistant",\n                "content": "MLflow is an open-source platform for machine learning (ML) and deep learning (DL) model management, monitoring, and",\n            },\n            "finish_reason": "stop",\n        }\n    ],\n    "model": "llama3.2:1b",\n    "object": "chat.completion",\n    "created": 1731000733,\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["In summary, ",(0,l.jsx)(n.code,{children:"ChatModel"})," provides a more structured approach to defining custom chat models, with a focus on standardized,\nOpenAI-compatible inputs and outputs. While it requires a bit more setup work to map the input/output schemas between the\n",(0,l.jsx)(n.code,{children:"ChatModel"})," schema and the application it wraps, it can be easier to use than a fully custom ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.PythonModel",children:(0,l.jsx)(n.code,{children:"PythonModel"})}),"\nas it handles the often-challenging task of defining input/output/parameter schemas. The ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.PythonModel",children:(0,l.jsx)(n.code,{children:"PythonModel"})})," approach,\non the other hand, provides the most flexibility but requires the developer to manually handle all of the input/output/parameter mapping logic."]}),"\n",(0,l.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,l.jsx)(n.p,{children:"In this guide, you have learned:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"How to map the input/output schemas between the ChatModel API and your application"}),"\n",(0,l.jsx)(n.li,{children:"How to configure commonly-used chat model inference parameters with the ChatModel API"}),"\n",(0,l.jsxs)(n.li,{children:["How to pass custom parameters to a ",(0,l.jsx)(n.code,{children:"ChatModel"})," using the ",(0,l.jsx)(n.code,{children:"custom_inputs"})," key"]}),"\n",(0,l.jsxs)(n.li,{children:["How ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.ChatModel",children:(0,l.jsx)(n.code,{children:"ChatModel"})})," compares to the ",(0,l.jsx)(s.B,{fn:"mlflow.pyfunc.PythonModel",children:(0,l.jsx)(n.code,{children:"PythonModel"})})," for defining custom chat models"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"You should now have a good sense of what the ChatModel API is and how it can be used to define custom chat models."}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"ChatModel"})," includes some additional functionality that was not covered in this introductory guide, including:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Out of the box support for MLflow Tracing, which is useful for debugging and monitoring your chat models, especially in models with multiple components or calls to LLM APIs."}),"\n",(0,l.jsx)(n.li,{children:"Support for customizing the model's configuration using an external configuration file."}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["To learn more about these and other advanced features of the ChatModel API, you can read ",(0,l.jsx)(n.a,{href:"/genai/flavors/chat-model-guide",children:"this guide"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(m,{...e})}):m(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>i});var t=o(96540);const l={},a=t.createContext(l);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},49374:(e,n,o)=>{o.d(n,{B:()=>r});o(96540);const t=JSON.parse('{"mlflow.anthropic":"api_reference/python_api/mlflow.anthropic.html","mlflow.artifacts":"api_reference/python_api/mlflow.artifacts.html","mlflow.ag2":"api_reference/python_api/mlflow.ag2.html","mlflow.autogen":"api_reference/python_api/mlflow.autogen.html","mlflow.bedrock":"api_reference/python_api/mlflow.bedrock.html","mlflow.catboost":"api_reference/python_api/mlflow.catboost.html","mlflow.client":"api_reference/python_api/mlflow.client.html","mlflow.config":"api_reference/python_api/mlflow.config.html","mlflow.crewai":"api_reference/python_api/mlflow.crewai.html","mlflow.data":"api_reference/python_api/mlflow.data.html","mlflow.deployments":"api_reference/python_api/mlflow.deployments.html","mlflow.diviner":"api_reference/python_api/mlflow.diviner.html","mlflow.dspy":"api_reference/python_api/mlflow.dspy.html","mlflow.entities":"api_reference/python_api/mlflow.entities.html","mlflow.environment_variables":"api_reference/python_api/mlflow.environment_variables.html","mlflow.gateway":"api_reference/python_api/mlflow.gateway.html","mlflow.gemini":"api_reference/python_api/mlflow.gemini.html","mlflow.groq":"api_reference/python_api/mlflow.groq.html","mlflow.h2o":"api_reference/python_api/mlflow.h2o.html","mlflow.johnsnowlabs":"api_reference/python_api/mlflow.johnsnowlabs.html","mlflow.keras":"api_reference/python_api/mlflow.keras.html","mlflow.langchain":"api_reference/python_api/mlflow.langchain.html","mlflow.lightgbm":"api_reference/python_api/mlflow.lightgbm.html","mlflow.litellm":"api_reference/python_api/mlflow.litellm.html","mlflow.llama_index":"api_reference/python_api/mlflow.llama_index.html","mlflow.metrics":"api_reference/python_api/mlflow.metrics.html","mlflow.mistral":"api_reference/python_api/mlflow.mistral.html","mlflow.models":"api_reference/python_api/mlflow.models.html","mlflow.onnx":"api_reference/python_api/mlflow.onnx.html","mlflow.openai":"api_reference/python_api/mlflow.openai.html","mlflow.paddle":"api_reference/python_api/mlflow.paddle.html","mlflow.pmdarima":"api_reference/python_api/mlflow.pmdarima.html","mlflow.projects":"api_reference/python_api/mlflow.projects.html","mlflow.promptflow":"api_reference/python_api/mlflow.promptflow.html","mlflow.prophet":"api_reference/python_api/mlflow.prophet.html","mlflow.pyfunc":"api_reference/python_api/mlflow.pyfunc.html","mlflow.pyspark.ml":"api_reference/python_api/mlflow.pyspark.ml.html","mlflow.pytorch":"api_reference/python_api/mlflow.pytorch.html","mlflow":"api_reference/python_api/mlflow.html","mlflow.sagemaker":"api_reference/python_api/mlflow.sagemaker.html","mlflow.sentence_transformers":"api_reference/python_api/mlflow.sentence_transformers.html","mlflow.server":"api_reference/python_api/mlflow.server.html","mlflow.shap":"api_reference/python_api/mlflow.shap.html","mlflow.sklearn":"api_reference/python_api/mlflow.sklearn.html","mlflow.spacy":"api_reference/python_api/mlflow.spacy.html","mlflow.spark":"api_reference/python_api/mlflow.spark.html","mlflow.statsmodels":"api_reference/python_api/mlflow.statsmodels.html","mlflow.system_metrics":"api_reference/python_api/mlflow.system_metrics.html","mlflow.tensorflow":"api_reference/python_api/mlflow.tensorflow.html","mlflow.tracing":"api_reference/python_api/mlflow.tracing.html","mlflow.transformers":"api_reference/python_api/mlflow.transformers.html","mlflow.types":"api_reference/python_api/mlflow.types.html","mlflow.utils":"api_reference/python_api/mlflow.utils.html","mlflow.xgboost":"api_reference/python_api/mlflow.xgboost.html","mlflow.server.auth":"api_reference/auth/python-api.html"}');var l=o(86025),a=o(28774),s=o(74848);const i=e=>{const n=e.split(".");for(let o=n.length;o>0;o--){const e=n.slice(0,o).join(".");if(t[e])return e}return null};function r({fn:e,children:n}){const o=i(e);if(!o)return(0,s.jsx)(s.Fragment,{children:n});const r=(0,l.Ay)(`/${t[o]}#${e}`);return(0,s.jsx)(a.A,{to:r,target:"_blank",children:n??(0,s.jsxs)("code",{children:[e,"()"]})})}},72839:(e,n,o)=>{o.d(n,{X:()=>l});var t=o(74848);function l({children:e}){return(0,t.jsx)("div",{className:"w-full overflow-x-auto",children:(0,t.jsx)("table",{children:e})})}}}]);