"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[627],{274:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>m});var a=t(5893),i=t(1151);const o={title:"AutoGen with Custom PyFunc",description:"A guide for building an autonomous image generation agent",tags:["genai","mlops"],slug:"autogen-image-agent",authors:["michael-berk","mlflow-maintainers"],thumbnail:"/img/blog/autogen-blog.png"},s=void 0,r={permalink:"/mlflow-website/blog/autogen-image-agent",source:"@site/blog/2024-08-29-autogen-pyfunc/index.md",title:"AutoGen with Custom PyFunc",description:"A guide for building an autonomous image generation agent",date:"2024-08-29T00:00:00.000Z",formattedDate:"August 29, 2024",tags:[{label:"genai",permalink:"/mlflow-website/blog/tags/genai"},{label:"mlops",permalink:"/mlflow-website/blog/tags/mlops"}],readingTime:21.295,hasTruncateMarker:!0,authors:[{name:"Michael Berk",title:"Sr. Resident Solutions Architect at Databricks",url:"https://www.linkedin.com/in/-michael-berk/",imageURL:"/img/authors/michael_berk.png",key:"michael-berk"},{name:"MLflow maintainers",title:"MLflow maintainers",url:"https://github.com/mlflow/mlflow.git",imageURL:"https://github.com/mlflow-automation.png",key:"mlflow-maintainers"}],frontMatter:{title:"AutoGen with Custom PyFunc",description:"A guide for building an autonomous image generation agent",tags:["genai","mlops"],slug:"autogen-image-agent",authors:["michael-berk","mlflow-maintainers"],thumbnail:"/img/blog/autogen-blog.png"},unlisted:!1,prevItem:{title:"Models from Code Logging in MLflow - What, Why, and How",permalink:"/mlflow-website/blog/models_from_code"},nextItem:{title:"LangGraph with Model From Code",permalink:"/mlflow-website/blog/langgraph-model-from-code"}},l={authorsImageUrls:[void 0,void 0]},m=[{value:"Agent Frameworks",id:"agent-frameworks",level:2},{value:"Agent Frameworks with AutoGen",id:"agent-frameworks-with-autogen",level:2},{value:"Setup",id:"setup",level:2},{value:"Environment Setup",id:"environment-setup",level:3},{value:"Create Our Agent Framework with AutoGen and MLflow",id:"create-our-agent-framework-with-autogen-and-mlflow",level:2},{value:"Agent Code",id:"agent-code",level:3},{value:"MLflow Model From Code",id:"mlflow-model-from-code",level:3},{value:"Use Our Agent Framework",id:"use-our-agent-framework",level:2},{value:"Log and Load",id:"log-and-load",level:3},{value:"Show MLflow Traces",id:"show-mlflow-traces",level:3},{value:"Logging Artifacts with MLflow",id:"logging-artifacts-with-mlflow",level:3},{value:"Additional Benefits of MLflow",id:"additional-benefits-of-mlflow",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["In this blog, we'll guide you through creating an ",(0,a.jsx)(n.a,{href:"https://microsoft.github.io/autogen/",children:"AutoGen"})," agent framework within an MLflow custom PyFunc. By combining MLflow with AutoGen's ability to create multi-agent frameworks, we are able to create scalable and stable GenAI applications."]}),"\n",(0,a.jsx)(n.h2,{id:"agent-frameworks",children:"Agent Frameworks"}),"\n",(0,a.jsx)(n.p,{children:"Agent frameworks enable autonomous agents to handle complex, multi-turn tasks by integrating discrete logic at each step. These frameworks are crucial for LLM-driven workflows, where agents manage dynamic interactions across multiple stages. Each agent operates based on specific logic, enabling precise task automation, decision-making, and coordination. This is ideal for applications like workflow orchestration, customer support, and multi-agent systems, where LLMs must interpret evolving context and respond accordingly."}),"\n",(0,a.jsx)(n.h2,{id:"agent-frameworks-with-autogen",children:"Agent Frameworks with AutoGen"}),"\n",(0,a.jsxs)(n.p,{children:["AutoGen is an open-source programming framework designed for building agent-based AI systems. It offers a multi-agent conversation framework, allowing users to build ",(0,a.jsx)(n.a,{href:"https://microsoft.github.io/autogen/docs/Examples/",children:"complex LLM workflows"})," using high-level abstractions. AutoGen simplifies the creation of diverse applications across various domains by providing pre-built systems. Additionally, it enhances LLM inference and optimization through specialized APIs, improving performance and reducing operational costs. The framework is tailored to streamline the development and deployment of agentic AI solutions."]}),"\n",(0,a.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,a.jsxs)(n.p,{children:["First, let's install the required dependencies. Note that pyautogen requires ",(0,a.jsx)(n.code,{children:"python>=3.9"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"environment-setup",children:"Environment Setup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"%pip install pyautogen mlflow -U -q\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We must also get API credentials to use an LLM. For this tutorial, we'll be using OpenAI. Note that a great way to securely pass tokens to your interactive python environment is via the ",(0,a.jsx)(n.a,{href:"https://docs.python.org/3/library/getpass.html",children:"getpass"})," package."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import os\nfrom getpass import getpass\n\nos.environ["OPENAI_API_KEY"] = getpass("OPENAI_API_KEY:")\n\nassert os.getenv("OPENAI_API_KEY"), "Please set an OPENAI_API_KEY environment variable."\n'})}),"\n",(0,a.jsx)(n.p,{children:"Great! We've setup our authentication configuration and are ready to start building an agent framework."}),"\n",(0,a.jsx)(n.h2,{id:"create-our-agent-framework-with-autogen-and-mlflow",children:"Create Our Agent Framework with AutoGen and MLflow"}),"\n",(0,a.jsxs)(n.p,{children:["In this tutorial we will be creating an image generation agent framework. There is a lot of code copied and modified from the ",(0,a.jsx)(n.a,{href:"https://github.com/microsoft/autogen/blob/main/notebook/agentchat_dalle_and_gpt4v.ipynb",children:"autogen tutorial"}),", but the core agent functionality remains the same."]}),"\n",(0,a.jsx)(n.h3,{id:"agent-code",children:"Agent Code"}),"\n",(0,a.jsx)(n.p,{children:"You don't have to worry about the specifics of the implementation. At a high level, we are creating an agent framework that..."}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Takes a prompt."}),"\n",(0,a.jsxs)(n.li,{children:["Leverages ",(0,a.jsx)(n.a,{href:"https://openai.com/index/dall-e-3/",children:"OpenAI's DALLE"})," to create an image based on that prompt."]}),"\n",(0,a.jsx)(n.li,{children:'Iteratively "catifies" e.g. adds fluffy cats to the image.'}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Step 3 is where AutoGen shines. We're able to leverage AutoGen's ",(0,a.jsx)(n.a,{href:"https://microsoft.github.io/autogen/docs/reference/agentchat/contrib/multimodal_conversable_agent#multimodalconversableagent",children:"MultimodalConversableAgent"}),' to create a critic agent that observes the images and, based on a system prompt provided by the user to "add fluffy cats", gives feedback on how the prompt should be improved.']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import os\nimport re\nfrom typing import Dict, List, Optional, Union\n\nimport matplotlib.pyplot as plt\nimport PIL\nfrom diskcache import Cache\nfrom openai import OpenAI\nfrom PIL import Image\n\nfrom autogen import Agent, AssistantAgent, ConversableAgent, UserProxyAgent\nfrom autogen.agentchat.contrib.img_utils import _to_pil, get_image_data, get_pil_image\nfrom autogen.agentchat.contrib.multimodal_conversable_agent import MultimodalConversableAgent\n\n# Define our prompt of interest\nCRITIC_PROMPT = """Add fluffy cats. Like a lot of cats. If there\'s less than 100 cats I\'ll be mad."""\n\n# Define our LLM configurations\n\ndef dalle_call(client: OpenAI, model: str, prompt: str, size: str, quality: str, n: int) -> str:\n    """\n    Generate an image using OpenAI\'s DALL-E model and cache the result.\n\n    This function takes a prompt and other parameters to generate an image using OpenAI\'s DALL-E model.\n    It checks if the result is already cached; if so, it returns the cached image data. Otherwise,\n    it calls the DALL-E API to generate the image, stores the result in the cache, and then returns it.\n\n    Args:\n        client (OpenAI): The OpenAI client instance for making API calls.\n        model (str): The specific DALL-E model to use for image generation.\n        prompt (str): The text prompt based on which the image is generated.\n        size (str): The size specification of the image.\n        quality (str): The quality setting for the image generation.\n        n (int): The number of images to generate.\n\n    Returns:\n    str: The image data as a string, either retrieved from the cache or newly generated.\n\n    Note:\n    - The cache is stored in a directory named \'.cache/\'.\n    - The function uses a tuple of (model, prompt, size, quality, n) as the key for caching.\n    - The image data is obtained by making a secondary request to the URL provided by the DALL-E API response.\n    """\n    # Function implementation...\n    cache = Cache(".cache/")  # Create a cache directory\n    key = (model, prompt, size, quality, n)\n    if key in cache:\n        return cache[key]\n\n    # If not in cache, compute and store the result\n    response = client.images.generate(\n        model=model,\n        prompt=prompt,\n        size=size,\n        quality=quality,\n        n=n,\n    )\n    image_url = response.data[0].url\n    img_data = get_image_data(image_url)\n    cache[key] = img_data\n\n    return img_data\n\ndef extract_img(agent: Agent) -> PIL.Image:\n    """\n    Extracts an image from the last message of an agent and converts it to a PIL image.\n\n    This function searches the last message sent by the given agent for an image tag,\n    extracts the image data, and then converts this data into a PIL (Python Imaging Library) image object.\n\n    Parameters:\n        agent (Agent): An instance of an agent from which the last message will be retrieved.\n\n    Returns:\n        PIL.Image: A PIL image object created from the extracted image data.\n\n    Note:\n    - The function assumes that the last message contains an <img> tag with image data.\n    - The image data is extracted using a regular expression that searches for <img> tags.\n    - It\'s important that the agent\'s last message contains properly formatted image data for successful extraction.\n    - The `_to_pil` function is used to convert the extracted image data into a PIL image.\n    - If no <img> tag is found, or if the image data is not correctly formatted, the function may raise an error.\n    """\n    last_message = agent.last_message()["content"]\n\n    if isinstance(last_message, str):\n        img_data = re.findall("<img (.*)>", last_message)[0]\n    elif isinstance(last_message, list):\n        # The GPT-4V format, where the content is an array of data\n        assert isinstance(last_message[0], dict)\n        img_data = last_message[0]["image_url"]["url"]\n\n    pil_img = get_pil_image(img_data)\n    return pil_img\n\nclass DALLEAgent(ConversableAgent):\n    def __init__(self, name, llm_config: dict, **kwargs):\n        super().__init__(name, llm_config=llm_config, **kwargs)\n\n        api_key = os.getenv("OPENAI_API_KEY")\n        self._dalle_client = OpenAI(api_key=api_key)\n        self.register_reply([Agent, None], DALLEAgent.generate_dalle_reply)\n\n    def send(\n        self,\n        message: Union[Dict, str],\n        recipient: Agent,\n        request_reply: Optional[bool] = None,\n        silent: Optional[bool] = False,\n    ):\n        # override and always "silent" the send out message;\n        # otherwise, the print log would be super long!\n        super().send(message, recipient, request_reply, silent=True)\n\n    def generate_dalle_reply(self, messages: Optional[List[Dict]], sender: "Agent", config):\n        """Generate a reply using OpenAI DALLE call."""\n        client = self._dalle_client if config is None else config\n        if client is None:\n            return False, None\n        if messages is None:\n            messages = self._oai_messages[sender]\n\n        prompt = messages[-1]["content"]\n        img_data = dalle_call(\n            client=client,\n            model="dall-e-3",\n            prompt=prompt,\n            size="1024x1024",\n            quality="standard",\n            n=1,\n        )\n\n        img_data = _to_pil(img_data)  # Convert to PIL image\n\n        # Return the OpenAI message format\n        return True, {"content": [{"type": "image_url", "image_url": {"url": img_data}}]}\n\nclass CatifyWithDalle(AssistantAgent):\n    def __init__(self, n_iters=2, **kwargs):\n        """\n        Initializes a CatifyWithDalle instance.\n\n        This agent facilitates the creation of visualizations through a collaborative effort among\n        its child agents: dalle and critics.\n\n        Parameters:\n            - n_iters (int, optional): The number of "improvement" iterations to run. Defaults to 2.\n            - **kwargs: keyword arguments for the parent AssistantAgent.\n        """\n        super().__init__(**kwargs)\n        self.register_reply([Agent, None], reply_func=CatifyWithDalle._reply_user, position=0)\n        self._n_iters = n_iters\n\n    def _reply_user(self, messages=None, sender=None, config=None):\n        if all((messages is None, sender is None)):\n            error_msg = f"Either {messages=} or {sender=} must be provided."\n            raise AssertionError(error_msg)\n\n        if messages is None:\n            messages = self._oai_messages[sender]\n\n        img_prompt = messages[-1]["content"]\n\n        ## Define the agents\n        self.critics = MultimodalConversableAgent(\n            name="Critics",\n            system_message=f"""You need to improve the prompt of the figures you saw.\n{CRITIC_PROMPT}\nReply with the following format:\n\nCRITICS: the image needs to improve...\nPROMPT: here is the updated prompt!\n\n""",\n            llm_config={"max_tokens": 1000, "model": "gpt-4o"},\n            human_input_mode="NEVER",\n            max_consecutive_auto_reply=3,\n        )\n\n        self.dalle = DALLEAgent(\n            name="Dalle", llm_config={"model": "dalle"}, max_consecutive_auto_reply=0\n        )\n\n        # Data flow begins\n        self.send(message=img_prompt, recipient=self.dalle, request_reply=True)\n        img = extract_img(self.dalle)\n        plt.imshow(img)\n        plt.axis("off")  # Turn off axis numbers\n        plt.show()\n        print("Image PLOTTED")\n\n        for i in range(self._n_iters):\n            # Downsample the image s.t. GPT-4V can take\n            img = extract_img(self.dalle)\n            smaller_image = img.resize((128, 128), Image.Resampling.LANCZOS)\n            smaller_image.save("result.png")\n\n            self.msg_to_critics = f"""Here is the prompt: {img_prompt}.\n            Here is the figure <img result.png>.\n            Now, critique and create a prompt so that DALLE can give me a better image.\n            Show me both "CRITICS" and "PROMPT"!\n            """\n            self.send(message=self.msg_to_critics, recipient=self.critics, request_reply=True)\n            feedback = self._oai_messages[self.critics][-1]["content"]\n            img_prompt = re.findall("PROMPT: (.*)", feedback)[0]\n\n            self.send(message=img_prompt, recipient=self.dalle, request_reply=True)\n            img = extract_img(self.dalle)\n            plt.imshow(img)\n            plt.axis("off")  # Turn off axis numbers\n            plt.show()\n            print(f"Image {i} PLOTTED")\n\n        return True, "result.jpg"\n\n'})}),"\n",(0,a.jsx)(n.p,{children:"Great! We have an agent framework. To quickly show how it works, let's instantiate our agent and give it a prompt."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'creator = CatifyWithDalle(\n    name="creator",\n    max_consecutive_auto_reply=0,\n    system_message="Help me coordinate generating image",\n    llm_config={"model": "gpt-4"},\n)\n\nuser_proxy = UserProxyAgent(\n    name="User",\n    human_input_mode="NEVER",\n    max_consecutive_auto_reply=0,\n    code_execution_config={\n        "work_dir": "output", # Location where code will be written\n        "use_docker": False # Use local jupyter execution environment instead of docker\n    }\n)\n\n_ = user_proxy.initiate_chat(\n    creator, message="Show me something boring"\n)\n'})}),"\n",(0,a.jsx)(n.p,{children:"The initial result from the first iteration from the user prompt:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"User (to creator):\n\nShow me something boring\n\ncreator (to Dalle):\n\nShow me something boring\n\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"An uninspired image",src:t(9568).Z+"",width:"389",height:"389"})}),"\n",(0,a.jsx)(n.p,{children:"This is definitely a boring room. Notice the responses of the critics and how the critics enhance the submission prompt in the following iterations."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'Image PLOTTED\ncreator (to Critics):\n\nHere is the prompt: Show me something boring.\nHere is the figure `<image>`.\nNow, critique and create a prompt so that DALLE can give me a better image.\nShow me both "CRITICS" and "PROMPT"!\n\nCritics (to creator):\n\nCRITICS: The image is simple and mundane, with a plain room and basic furniture, which accomplishes the task of showing something boring. However, it can be improved by adding an element of whimsy or interest, juxtaposing the boring scene with something unexpected. Let\'s add a lot of cats to make it more engaging.\n\nPROMPT: Show me a boring living room with plain furniture, but add 100 cats in various places around the room.\n\ncreator (to Dalle):\n\nShow me a boring living room with plain furniture, but add 100 cats in various places around the room.\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"A mild improvement",src:t(3441).Z+"",width:"389",height:"389"})}),"\n",(0,a.jsx)(n.p,{children:"On the final iteration, we can see a more refined instruction set to add additional details."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'\nImage 0 PLOTTED\ncreator (to Critics):\n\nHere is the prompt: Show me a boring living room with plain furniture, but add 100 cats in various places around the room..\nHere is the figure `<image>`.\nNow, critique and create a prompt so that DALLE can give me a better image.\nShow me both "CRITICS" and "PROMPT"!\n\nCritics (to creator):\n\nCRITICS: The image has successfully incorporated cats into a boring living room, bringing in an element of surprise and quirkiness. However, it is in black and white, which can make the image feel duller and less lively. Additionally, while there are many cats, they could be positioned in more playful and unexpected ways to create more interest.\n\nPROMPT: Show me a colorful, boring living room with plain furniture, but add 100 cats in various imaginative and playful positions around the room.\n\ncreator (to Dalle):\n\nShow me a colorful, boring living room with plain furniture, but add 100 cats in various imaginative and playful positions around the room.\n\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Final cat room",src:t(6073).Z+"",width:"389",height:"389"})}),"\n",(0,a.jsx)(n.p,{children:"Without any direct intervention, we now have an image that is remarkably different in style than the original user instruction. The agent has successfully\nintroduced elements of whimsy into the original instruction set."}),"\n",(0,a.jsx)(n.h3,{id:"mlflow-model-from-code",children:"MLflow Model From Code"}),"\n",(0,a.jsx)(n.p,{children:"Now that we've proven the concept, it's time to leverage MLflow to manage our ML modeling lifecycle. For instance, it's highly likely that we'd want to take this model to production, so strong dependency management, model versioning, and support for tracking between development cycles would all be useful."}),"\n",(0,a.jsxs)(n.p,{children:["In this blog we will leverage the ",(0,a.jsx)(n.a,{href:"https://mlflow.org/docs/latest/models.html#models-from-code",children:"Model from Code"})," feature to achieve the above functionality. MLflow Model from Code allows you to define and log models directly from a stand-alone python script. This feature is particularly useful when you want to log models that can be effectively stored as a code representation (models that do not need optimized weights through training) or applications that rely on external services (e.g., LangChain chains). Another benefit is that this approach entirely bypasses the use of the ",(0,a.jsx)(n.code,{children:"pickle"})," or ",(0,a.jsx)(n.code,{children:"cloudpickle"})," modules within Python, which can carry security"]}),"\n",(0,a.jsx)(n.p,{children:"To leverage Model from Code, we must perform the following steps:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Declare a ",(0,a.jsx)(n.a,{href:"https://mlflow.org/docs/latest/traditional-ml/creating-custom-pyfunc/index.html",children:"custom PyFunc"})]}),"\n",(0,a.jsxs)(n.li,{children:["Leverage ",(0,a.jsx)(n.a,{href:"https://mlflow.org/docs/latest/python_api/mlflow.models.html?highlight=set_model#mlflow.models.set_model",children:"mlflow.models.set_model"})," to indicate which python object is our model."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["To achieve these steps, we simply copy the above and below code to a python file. For simplicity, you can just create a single Python file with both code snippets, but MLflow also supports specifying local dependencies when logging our model via the ",(0,a.jsx)(n.code,{children:"code_paths"})," parameter in ",(0,a.jsx)(n.a,{href:"https://mlflow.org/docs/latest/python_api/mlflow.pyfunc.html?highlight=pyfunc%20log_model#mlflow.pyfunc.log_model",children:"mlflow.pyfunc.lod_model"})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"This step was omitted for brevity and must be done manually."})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import mlflow\n\nclass CatifyPyfunc(mlflow.pyfunc.PythonModel):\n  def predict(self, context, model_input, params):\n    import mlflow\n    mlflow.autogen.autolog()\n\n    creator = CatifyWithDalle(\n            name="creator",\n            max_consecutive_auto_reply=0,\n            system_message="Help me coordinate generating image",\n            llm_config={"model":"gpt-4"},\n        )\n\n    user_proxy = UserProxyAgent(name="User", human_input_mode="NEVER", max_consecutive_auto_reply=0, code_execution_config={\n                "work_dir": "output", # Location where code will be written\n                "use_docker": False # Use local jupyter execution environment instead of docker\n            })\n\n    return user_proxy.initiate_chat(\n        creator, message=model_input\n    )\nmlflow.models.set_model(CatifyPyfunc())\n'})}),"\n",(0,a.jsx)(n.p,{children:'At the end of this step, you should have a Python file that has both code snippets. The name is up to the user, but for this blog we will use "catify_model.py".'}),"\n",(0,a.jsx)(n.h2,{id:"use-our-agent-framework",children:"Use Our Agent Framework"}),"\n",(0,a.jsx)(n.p,{children:'We are now positioned to leverage MLflow to interact with our powerful "catify" agent.'}),"\n",(0,a.jsx)(n.h3,{id:"log-and-load",children:"Log and Load"}),"\n",(0,a.jsx)(n.p,{children:"First, let's demonstrate the standard user journey of logging model to MLflow's tracking server. We will then load it back and perform inference."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import mlflow\nmlflow.autogen.autolog() # Enable logging of traces\n\nwith mlflow.start_run() as run:\n    mlflow.pyfunc.log_model(\n        artifact_path="autogen_pyfunc",\n        python_model="catify_model.py", # Our model from code python file\n\n    )\n\n    run_id = run.info.run_id\n'})}),"\n",(0,a.jsx)(n.p,{children:"With our model logged, let's reload it and perform inference, this time with a more cool prompt."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'loaded = mlflow.pyfunc.load_model(f"runs:/{run_id}/autogen_pyfunc")\nout = loaded.predict("The matrix with a cat")\n'})}),"\n",(0,a.jsx)(n.p,{children:"The initial stage's results:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"User (to creator):\n\nThe matrix with a cat\n\ncreator (to Dalle):\n\nThe matrix with a cat\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Initial Matrix Cat",src:t(1734).Z+"",width:"389",height:"389"})}),"\n",(0,a.jsx)(n.p,{children:"On the next stage, the generation prompt is greatly enhanced by the critic agent."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'Image PLOTTED\ncreator (to Critics):\n\nHere is the prompt: The matrix with a cat.\nHere is the figure `<image>`.\nNow, critique and create a prompt so that DALLE can give me a better image.\nShow me both "CRITICS" and "PROMPT"!\n\nCritics (to creator):\n\nCRITICS: The image effectively captures the Matrix-themed aesthetic with a cat, combining a cyberpunk atmosphere with digital elements. However, to improve the image:\n\n- Increase the number of cats to align with the requirement of having lots of cats (aim for around 100).\n- Enhance the digital and neon elements to make the Matrix theme more pronounced.\n- Add more movement or dynamic elements to the scene for a more immersive feel.\n- Ensure diversity in cat appearances, sizes, and positions to make the scene more complex and interesting.\n\nPROMPT: "Create a Matrix-themed scene set in a cyberpunk alleyway, with digital and neon elements filling the atmosphere. The scene should feature around 100 cats of various sizes, colors, and positions\u2014some sitting, some walking, and some interacting with the digital elements. Make the digital grid and floating code more prominent, and add dynamic elements such as digital rain or floating holograms to create a more immersive and lively environment."\n\ncreator (to Dalle):\n\n"Create a Matrix-themed scene set in a cyberpunk alleyway, with digital and neon elements filling the atmosphere. The scene should feature around 100 cats of various sizes, colors, and positions\u2014some sitting, some walking, and some interacting with the digital elements. Make the digital grid and floating code more prominent, and add dynamic elements such as digital rain or floating holograms to create a more immersive and lively environment."\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"First Matrix Iteration",src:t(6246).Z+"",width:"389",height:"389"})}),"\n",(0,a.jsx)(n.p,{children:"This is definitely an improvement, show casing the power of multi-turn agents."}),"\n",(0,a.jsx)(n.p,{children:"The final stage enhances the instruction set even further."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'Image 0 PLOTTED\ncreator (to Critics):\n\nHere is the prompt: "Create a Matrix-themed scene set in a cyberpunk alleyway, with digital and neon elements filling the atmosphere. The scene should feature around 100 cats of various sizes, colors, and positions\u2014some sitting, some walking, and some interacting with the digital elements. Make the digital grid and floating code more prominent, and add dynamic elements such as digital rain or floating holograms to create a more immersive and lively environment.".\nHere is the figure `<image>`.\nNow, critique and create a prompt so that DALLE can give me a better image.\nShow me both "CRITICS" and "PROMPT"!\n\nCritics (to creator):\n\nCRITICS: The image significantly improves the Matrix-themed atmosphere with a cyberpunk alley and an abundance of cats. However, there are a few areas for improvement:\n\n- Increase the variety of the digital elements (e.g., different shapes of holograms, varied colors and intensities of neon signs).\n- Make the cats more dynamic by showing more interactions such as jumping, playing, or chasing digital elements.\n- Enhance the depth and perspective of the scene to create a more three-dimensional and immersive look.\n- Add more detail to the surrounding environment, like futuristic posters or graffiti to intensify the cyberpunk feel.\n\nPROMPT: "Craft a highly detailed, Matrix-themed scene set in a cyberpunk alleyway. The atmosphere should be rich with diverse digital and neon elements, including various shapes of holograms and a range of vivid colors. Populate the scene with around 100 dynamic cats of different sizes, colors, and actions\u2014some sitting, some walking, some jumping, playing, or chasing digital elements. Enhance the depth and perspective of the scene to create a more immersive three-dimensional experience. Include detailed futuristic environment elements like posters, graffiti, and neon signs to intensify the cyberpunk feel."\n\ncreator (to Dalle):\n\n"Craft a highly detailed, Matrix-themed scene set in a cyberpunk alleyway. The atmosphere should be rich with diverse digital and neon elements, including various shapes of holograms and a range of vivid colors. Populate the scene with around 100 dynamic cats of different sizes, colors, and actions\u2014some sitting, some walking, some jumping, playing, or chasing digital elements. Enhance the depth and perspective of the scene to create a more immersive three-dimensional experience. Include detailed futuristic environment elements like posters, graffiti, and neon signs to intensify the cyberpunk feel."\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"2nd cool image",src:t(5101).Z+"",width:"389",height:"389"})}),"\n",(0,a.jsx)(n.p,{children:"A little dystopian, but we'll take it!"}),"\n",(0,a.jsx)(n.p,{children:"We have successfully demonstrated that we can log and load our model, then perform inference from the loaded model."}),"\n",(0,a.jsx)(n.h3,{id:"show-mlflow-traces",children:"Show MLflow Traces"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://mlflow.org/docs/latest/llms/tracing/index.html",children:"MLflow Tracing"})," provides a thread-safe API to track the execution of complex applications. The MLflow AutoGen flavor has tracing built in as an autologging feature. So, simply by running ",(0,a.jsx)(n.code,{children:"mlflow.autogen.autolog()"})," prior to doing inference, we will get traces logged automatically."]}),"\n",(0,a.jsx)(n.p,{children:"Traces can be accessed via the fluent APIs, MLflow client, and manually via the MLflow UI. For more, please visit the documentation linked above."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Example with fluent APIs\nlast_active_trace = mlflow.get_last_active_trace()\nprint(last_active_trace)\n\n# Output: Trace(request_id=71ffcf92785b4dfc965760a43193095c)\n"})}),"\n",(0,a.jsx)(n.p,{children:"In the meantime, we will display the MLFlow UI here. If you are running in an interactive context, such as jupyter, run the following command."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import subprocess\nfrom IPython.display import IFrame\n\n# Start MLflow server in the background\nmlflow_ui_server = subprocess.Popen(["mlflow", "ui", "--host", "127.0.0.1", "--port", "5000"])\nIFrame(src="http://127.0.0.1:5000", width="100%", height="600")\n\n# Run the below command to stop the server\n# mlflow_ui_server.terminate()\n'})}),"\n",(0,a.jsx)(n.p,{children:"If you're not running interactively, you can simply run the follow shell command and navigate to the associated host and port in your web browser."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"mlflow ui\n"})}),"\n",(0,a.jsx)(n.p,{children:"If we navigate to the tracing tab, as shown in the image below, we can see our logged trace."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"The MLflow Tracing UI",src:t(4572).Z+"",width:"3406",height:"1070"})}),"\n",(0,a.jsxs)(n.p,{children:["By clicking on that trace ID, we can see a detailed execution plan. At the bottom, we can see our prompt ",(0,a.jsx)(n.code,{children:'"The matrix with a cat"'}),' which kicked off the chat session. From there, many agents interacted to create images and provide feedback to "catify" them. Also, note that the trace ID is the same as the one returned by ',(0,a.jsx)(n.code,{children:"mlflow.get_last_active_trace()"})," above."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"The MLflow Tracing UI",src:t(8051).Z+"",width:"2912",height:"1862"})}),"\n",(0,a.jsx)(n.p,{children:"Finally, let's dig a bit deeper on the tracing LLM call. As you can see, we have lots of valuable information about the execution, such as the model and usage statistics. Tracing helps you monitor not just performance, but cost, usage patterns, and much more! You can also leverage custom metadata to get even more granular insights."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"The MLflow Tracing UI",src:t(9481).Z+"",width:"2892",height:"1806"})}),"\n",(0,a.jsx)(n.h3,{id:"logging-artifacts-with-mlflow",children:"Logging Artifacts with MLflow"}),"\n",(0,a.jsx)(n.p,{children:"Tracing's primary purpose is to provide robust lightweight summaries of complex agent executions. For larger or custom payloads, MLflow exposes a variety of artifact-logging APIs that can store images, text, tables, and more in the MLflow tracking server. Let's quickly demonstrate this functionality by logging the prompts and their associated images."}),"\n",(0,a.jsxs)(n.p,{children:["Within our ",(0,a.jsx)(n.code,{children:"CatifyWithDalle"})," class, we will make 4 modifications..."]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Create an instance variable in the class ",(0,a.jsx)(n.code,{children:"__init__"})," to save metadata about our objects."]}),"\n",(0,a.jsxs)(n.li,{children:["Create a private utility to increment our metadata and log and images with ",(0,a.jsx)(n.a,{href:"https://mlflow.org/docs/latest/python_api/mlflow.html?highlight=log_image#mlflow.log_image",children:"mlflow.log_image"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Call the above utility after new images have been generated."}),"\n",(0,a.jsxs)(n.li,{children:["Finally, log our metadata object as JSON with ",(0,a.jsx)(n.a,{href:"https://mlflow.org/docs/latest/python_api/mlflow.html?highlight=log_image#mlflow.log_dict",children:"mlflow.log_dict"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import uuid  # Add to generate artifact file names and indeces for prompt mapping to generated images\n\nclass CatifyWithDalle(AssistantAgent):\n    def __init__(self, n_iters=2, **kwargs):\n        """\n        Initializes a CatifyWithDalle instance.\n\n        This agent facilitates the creation of visualizations through a collaborative effort among\n        its child agents: dalle and critics.\n\n        Parameters:\n            - n_iters (int, optional): The number of "improvement" iterations to run. Defaults to 2.\n            - **kwargs: keyword arguments for the parent AssistantAgent.\n        """\n        super().__init__(**kwargs)\n        self.register_reply([Agent, None], reply_func=CatifyWithDalle._reply_user, position=0)\n        self._n_iters = n_iters\n        self.dict_to_log = {}  # Add a buffer for storing mapping information\n\n    # Adding this method to log the generated images and the prompt-to-image mapping file\n    def _log_image_and_append_to_dict(self, img: Image, img_prompt: str, image_index: int)-> None:\n        """ Method for logging generated images to MLflow and building a prompt mapping file """\n        # Generate a unique ID\n        _id = str(uuid.uuid1())\n\n        # Append to class variable to log once at the end of all inference\n        self.dict_to_log[_id] = {"prompt": img_prompt, "index": image_index}\n\n        # Log image to MLflow tracking server\n        mlflow.log_image(img, f"{_id}.png")\n\n    def _reply_user(self, messages=None, sender=None, config=None):\n        if all((messages is None, sender is None)):\n            error_msg = f"Either {messages=} or {sender=} must be provided."\n            raise AssertionError(error_msg)\n\n        if messages is None:\n            messages = self._oai_messages[sender]\n\n        img_prompt = messages[-1]["content"]\n\n        ## Define the agents\n        self.critics = MultimodalConversableAgent(\n            name="Critics",\n            system_message=f"""You need to improve the prompt of the figures you saw.\n{CRITIC_PROMPT}\nReply with the following format:\n\nCRITICS: the image needs to improve...\nPROMPT: here is the updated prompt!\n\n""",\n            llm_config={"max_tokens": 1000, "model": "gpt-4o"},\n            human_input_mode="NEVER",\n            max_consecutive_auto_reply=3,\n        )\n\n        self.dalle = DALLEAgent(\n            name="Dalle", llm_config={"model": "dalle"}, max_consecutive_auto_reply=0\n        )\n\n        # Data flow begins\n        self.send(message=img_prompt, recipient=self.dalle, request_reply=True)\n        img = extract_img(self.dalle)\n        plt.imshow(img)\n        plt.axis("off")  # Turn off axis numbers\n        plt.show()\n        print("Image PLOTTED")\n\n        self._log_image_and_append_to_dict(img, img_prompt, -1)  # Add image logging and buffer updates\n\n        for i in range(self._n_iters):\n            # Downsample the image s.t. GPT-4V can take\n            img = extract_img(self.dalle)\n            smaller_image = img.resize((128, 128), Image.Resampling.LANCZOS)\n            smaller_image.save("result.png")\n\n            self.msg_to_critics = f"""Here is the prompt: {img_prompt}.\n            Here is the figure <img result.png>.\n            Now, critic and create a prompt so that DALLE can give me a better image.\n            Show me both "CRITICS" and "PROMPT"!\n            """\n            self.send(message=self.msg_to_critics, recipient=self.critics, request_reply=True)\n            feedback = self._oai_messages[self.critics][-1]["content"]\n            img_prompt = re.findall("PROMPT: (.*)", feedback)[0]\n\n            self.send(message=img_prompt, recipient=self.dalle, request_reply=True)\n            img = extract_img(self.dalle)\n            plt.imshow(img)\n            plt.axis("off")  # Turn off axis numbers\n            plt.show()\n            print(f"Image {i} PLOTTED")\n            self._log_image_and_append_to_dict(img, img_prompt, i)  # Log the image in the iteration\n\n\n\n        mlflow.log_dict(self.dict_to_log, "image_lookup.json")  # Log the prompt-to-image mapping buffer\n        return True, "result.jpg"\n'})}),"\n",(0,a.jsx)(n.p,{children:"Now, if we rerun the above model logging code, every time we load the newest version of our model, images generated by our agent will be logged and a JSON object with all prompts, indexes of the prompts, and image names (for lookup purposes) will be logged."}),"\n",(0,a.jsxs)(n.p,{children:["Let's demonstrate this and wrap infernce in a single MLflow run for easy aggregation. Also note that we will be leveraging Autogen's ",(0,a.jsx)(n.a,{href:"https://microsoft.github.io/autogen/docs/reference/cache/",children:"caching"})," functionality, so given we've already done inference with this prompt, we won't actually be making LLM calls again; we're just reading from cache and logging with our new MLflow code."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Be sure to re-log the model by rerunning the above code\nwith mlflow.start_run(run_name="log_image_during_inferfence"):\n    loaded = mlflow.pyfunc.load_model(f"runs:/{run_id}/autogen_pyfunc")\n    loaded.predict("The matrix with a cat")\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Logged Images and JSON Artifacts",src:t(7086).Z+"",width:"1755",height:"974"})}),"\n",(0,a.jsx)(n.p,{children:'As you can see, we have logged three images of interest and a lookup dict. The keys of the dict correspond to the image names and the values correspond to additional information for how the image was generated. With these artifacts we can perform detailed analyses on prompt quality and make iterative improvements to our "catify" agent!'}),"\n",(0,a.jsx)(n.h3,{id:"additional-benefits-of-mlflow",children:"Additional Benefits of MLflow"}),"\n",(0,a.jsx)(n.p,{children:"There is a lot more happening behind the scenes that is out of the scope of this tutorial, but here's a quick list of additional MLflow features that are useful when building agentic frameworks."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dependency management"}),": when you log a model, MLflow will automatically try to infer your pip requirements. These requirements are written in several formats that makes remote serving of your model much simpler. If you have local dependencies, as noted above, you can specify additional paths for MLflow to serialize via the ",(0,a.jsx)(n.code,{children:"code_paths"})," argument when logging your model."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Model aliasing"}),": when iteratively building your agentic framework, you want an easy way to compare models. MLflow model ",(0,a.jsx)(n.a,{href:"https://mlflow.org/docs/latest/model-registry.html#deploy-and-organize-models-with-aliases-and-tags",children:"aliases and tags"})," facilitate lookups to the MLflow model registry and allow you to easily load and deploy an specific model version."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Nested Runs"}),": with agentic frameworks, especially when training underlying LLM components, you will often have complex nested structures. MLflow supports ",(0,a.jsx)(n.a,{href:"https://mlflow.org/docs/latest/traditional-ml/hyperparameter-tuning-with-child-runs/part1-child-runs.html",children:"nested runs"})," to facilitate aggregating your run information. This can be especially useful with LLM training and fine tuning."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsxs)(n.p,{children:["In this blog we outlined how to create a complex agent with AutoGen. We also showed how to leverage the MLflow ",(0,a.jsx)(n.a,{href:"https://mlflow.org/docs/latest/models.html#models-from-code",children:"Model from Code"})," feature to log and load our model. Finally, we leveraged the MLflow AutoGen's autologging capabilities to automatically leverage MLflow tracing to get fine-grained and thread-safe agent execution information."]}),"\n",(0,a.jsx)(n.p,{children:"Happy coding!"})]})}function d(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},9568:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/boring_0-58e3e96a4d1a56d431f044ae22d31adb.png"},3441:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/boring_1-4267848a50f24376844a18e7fe7543a3.png"},6073:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/boring_2-4ee565a1848ea391f56bcca9a327ac9c.png"},1734:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/cool_0-d6729ef9b7346239662cd9a53b21c52f.png"},6246:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/cool_1-6c8e3b1405b0537c00e1b7037806997b.png"},5101:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/cool_2-0b7b423449ea4b44c90d48681b980bc1.png"},7086:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/logged_images-47157db604905efff1a73f995c64b5d7.png"},9481:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/tracing_chat_completion_1-cd942bdc4f6904ae270d182abb921cea.png"},8051:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/tracing_detail-d3bf5d68bc156658ed32a2ec2ed8bdbc.png"},4572:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/tracing_main_page-472be004e0f16bb292a369b923d7d909.png"},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>s});var a=t(7294);const i={},o=a.createContext(i);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);